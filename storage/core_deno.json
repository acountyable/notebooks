{
  "Deno": {
    "internal": "Symbol(Deno.internal)",
    "Process": "class Process {\n  constructor(res) {\n    this.rid = res.rid;\n    this.pid = res.pid;\n\n    if (res.stdinRid && res.stdinRid > 0) {\n      this.stdin = new FsFile(res.stdinRid, SymbolFor(\"Deno.internal.FsFile\"));\n    }\n\n    if (res.stdoutRid && res.stdoutRid > 0) {\n      this.stdout = new FsFile(\n        res.stdoutRid,\n        SymbolFor(\"Deno.internal.FsFile\"),\n      );\n    }\n\n    if (res.stderrRid && res.stderrRid > 0) {\n      this.stderr = new FsFile(\n        res.stderrRid,\n        SymbolFor(\"Deno.internal.FsFile\"),\n      );\n    }\n  }\n\n  status() {\n    return runStatus(this.rid);\n  }\n\n  async output() {\n    if (!this.stdout) {\n      throw new TypeError(\"Cannot collect output: 'stdout' is not piped\");\n    }\n    try {\n      return await readAll(this.stdout);\n    } finally {\n      this.stdout.close();\n    }\n  }\n\n  async stderrOutput() {\n    if (!this.stderr) {\n      throw new TypeError(\"Cannot collect output: 'stderr' is not piped\");\n    }\n    try {\n      return await readAll(this.stderr);\n    } finally {\n      this.stderr.close();\n    }\n  }\n\n  close() {\n    core.close(this.rid);\n  }\n\n  kill(signo = \"SIGTERM\") {\n    opKill(this.pid, signo, \"Deno.Process.kill()\");\n  }\n}",
    "run": "function run({\n  cmd,\n  cwd = undefined,\n  env = { __proto__: null },\n  stdout = \"inherit\",\n  stderr = \"inherit\",\n  stdin = \"inherit\",\n}) {\n  if (cmd[0] != null) {\n    cmd = [\n      pathFromURL(cmd[0]),\n      ...new SafeArrayIterator(ArrayPrototypeSlice(cmd, 1)),\n    ];\n  }\n  const res = opRun({\n    cmd: ArrayPrototypeMap(cmd, String),\n    cwd,\n    env: ObjectEntries(env),\n    stdin,\n    stdout,\n    stderr,\n  });\n  return new Process(res);\n}",
    "isatty": "function isatty(rid) {\n  return isTerminal(rid);\n}",
    "writeFileSync": "function writeFileSync(\n  path,\n  data,\n  options = { __proto__: null },\n) {\n  options.signal?.throwIfAborted();\n  op_fs_write_file_sync(\n    pathFromURL(path),\n    options.mode,\n    options.append ?? false,\n    options.create ?? true,\n    options.createNew ?? false,\n    data,\n  );\n}",
    "writeFile": "async function writeFile(\n  path,\n  data,\n  options = { __proto__: null },\n) {\n  let cancelRid;\n  let abortHandler;\n  if (options.signal) {\n    options.signal.throwIfAborted();\n    cancelRid = createCancelHandle();\n    abortHandler = () => core.tryClose(cancelRid);\n    options.signal[abortSignal.add](abortHandler);\n  }\n  try {\n    if (ObjectPrototypeIsPrototypeOf(ReadableStreamPrototype, data)) {\n      const file = await open(path, {\n        mode: options.mode,\n        append: options.append ?? false,\n        create: options.create ?? true,\n        createNew: options.createNew ?? false,\n        truncate: !(options.append ?? false),\n        write: true,\n      });\n      await data.pipeTo(file.writable, {\n        signal: options.signal,\n      });\n    } else {\n      await op_fs_write_file_async(\n        pathFromURL(path),\n        options.mode,\n        options.append ?? false,\n        options.create ?? true,\n        options.createNew ?? false,\n        data,\n        cancelRid,\n      );\n    }\n  } finally {\n    if (options.signal) {\n      options.signal[abortSignal.remove](abortHandler);\n\n      // always throw the abort error when aborted\n      options.signal.throwIfAborted();\n    }\n  }\n}",
    "writeTextFileSync": "function writeTextFileSync(\n  path,\n  data,\n  options = { __proto__: null },\n) {\n  const encoder = new TextEncoder();\n  return writeFileSync(path, encoder.encode(data), options);\n}",
    "writeTextFile": "function writeTextFile(\n  path,\n  data,\n  options = { __proto__: null },\n) {\n  if (ObjectPrototypeIsPrototypeOf(ReadableStreamPrototype, data)) {\n    return writeFile(\n      path,\n      data.pipeThrough(new TextEncoderStream()),\n      options,\n    );\n  } else {\n    const encoder = new TextEncoder();\n    return writeFile(path, encoder.encode(data), options);\n  }\n}",
    "readTextFile": "async function readTextFile(path, options) {\n  let cancelRid;\n  let abortHandler;\n  if (options?.signal) {\n    options.signal.throwIfAborted();\n    cancelRid = createCancelHandle();\n    abortHandler = () => core.tryClose(cancelRid);\n    options.signal[abortSignal.add](abortHandler);\n  }\n\n  try {\n    const read = await op_fs_read_file_text_async(\n      pathFromURL(path),\n      cancelRid,\n    );\n    return read;\n  } finally {\n    if (options?.signal) {\n      options.signal[abortSignal.remove](abortHandler);\n\n      // always throw the abort error when aborted\n      options.signal.throwIfAborted();\n    }\n  }\n}",
    "readTextFileSync": "function readTextFileSync(path) {\n  return op_fs_read_file_text_sync(pathFromURL(path));\n}",
    "readFile": "async function readFile(path, options) {\n  let cancelRid;\n  let abortHandler;\n  if (options?.signal) {\n    options.signal.throwIfAborted();\n    cancelRid = createCancelHandle();\n    abortHandler = () => core.tryClose(cancelRid);\n    options.signal[abortSignal.add](abortHandler);\n  }\n\n  try {\n    const read = await op_fs_read_file_async(\n      pathFromURL(path),\n      cancelRid,\n    );\n    return read;\n  } finally {\n    if (options?.signal) {\n      options.signal[abortSignal.remove](abortHandler);\n\n      // always throw the abort error when aborted\n      options.signal.throwIfAborted();\n    }\n  }\n}",
    "readFileSync": "function readFileSync(path) {\n  return op_fs_read_file_sync(pathFromURL(path));\n}",
    "watchFs": "function watchFs(\n  paths,\n  options = { __proto__: null, recursive: true },\n) {\n  return new FsWatcher(ArrayIsArray(paths) ? paths : [paths], options);\n}",
    "chmodSync": "function chmodSync(path, mode) {\n  op_fs_chmod_sync(pathFromURL(path), mode);\n}",
    "chmod": "async function chmod(path, mode) {\n  await op_fs_chmod_async(pathFromURL(path), mode);\n}",
    "chown": "async function chown(\n  path,\n  uid,\n  gid,\n) {\n  await op_fs_chown_async(\n    pathFromURL(path),\n    uid,\n    gid,\n  );\n}",
    "chownSync": "function chownSync(\n  path,\n  uid,\n  gid,\n) {\n  op_fs_chown_sync(pathFromURL(path), uid, gid);\n}",
    "copyFileSync": "function copyFileSync(\n  fromPath,\n  toPath,\n) {\n  op_fs_copy_file_sync(\n    pathFromURL(fromPath),\n    pathFromURL(toPath),\n  );\n}",
    "cwd": "function cwd() {\n  return op_fs_cwd();\n}",
    "makeTempDirSync": "function makeTempDirSync(options = { __proto__: null }) {\n  return op_fs_make_temp_dir_sync(\n    options.dir,\n    options.prefix,\n    options.suffix,\n  );\n}",
    "makeTempDir": "function makeTempDir(options = { __proto__: null }) {\n  return op_fs_make_temp_dir_async(\n    options.dir,\n    options.prefix,\n    options.suffix,\n  );\n}",
    "makeTempFileSync": "function makeTempFileSync(options = { __proto__: null }) {\n  return op_fs_make_temp_file_sync(\n    options.dir,\n    options.prefix,\n    options.suffix,\n  );\n}",
    "makeTempFile": "function makeTempFile(options = { __proto__: null }) {\n  return op_fs_make_temp_file_async(\n    options.dir,\n    options.prefix,\n    options.suffix,\n  );\n}",
    "memoryUsage": "() => op_runtime_memory_usage()",
    "mkdirSync": "function mkdirSync(path, options) {\n  op_fs_mkdir_sync(\n    pathFromURL(path),\n    options?.recursive ?? false,\n    options?.mode,\n  );\n}",
    "mkdir": "async function mkdir(path, options) {\n  await op_fs_mkdir_async(\n    pathFromURL(path),\n    options?.recursive ?? false,\n    options?.mode,\n  );\n}",
    "chdir": "function chdir(directory) {\n  op_fs_chdir(pathFromURL(directory));\n}",
    "copyFile": "async function copyFile(\n  fromPath,\n  toPath,\n) {\n  await op_fs_copy_file_async(\n    pathFromURL(fromPath),\n    pathFromURL(toPath),\n  );\n}",
    "readDirSync": "function readDirSync(path) {\n  return op_fs_read_dir_sync(pathFromURL(path))[\n    SymbolIterator\n  ]();\n}",
    "readDir": "function readDir(path) {\n  const array = op_fs_read_dir_async(\n    pathFromURL(path),\n  );\n  return {\n    async *[SymbolAsyncIterator]() {\n      const dir = await array;\n      for (let i = 0; i < dir.length; ++i) {\n        yield dir[i];\n      }\n    },\n  };\n}",
    "readLinkSync": "function readLinkSync(path) {\n  return op_fs_read_link_sync(pathFromURL(path));\n}",
    "readLink": "function readLink(path) {\n  return op_fs_read_link_async(pathFromURL(path));\n}",
    "realPathSync": "function realPathSync(path) {\n  return op_fs_realpath_sync(pathFromURL(path));\n}",
    "realPath": "function realPath(path) {\n  return op_fs_realpath_async(pathFromURL(path));\n}",
    "removeSync": "function removeSync(\n  path,\n  options = { __proto__: null },\n) {\n  op_fs_remove_sync(\n    pathFromURL(path),\n    !!options.recursive,\n  );\n}",
    "remove": "async function remove(\n  path,\n  options = { __proto__: null },\n) {\n  await op_fs_remove_async(\n    pathFromURL(path),\n    !!options.recursive,\n  );\n}",
    "renameSync": "function renameSync(oldpath, newpath) {\n  op_fs_rename_sync(\n    pathFromURL(oldpath),\n    pathFromURL(newpath),\n  );\n}",
    "rename": "async function rename(oldpath, newpath) {\n  await op_fs_rename_async(\n    pathFromURL(oldpath),\n    pathFromURL(newpath),\n  );\n}",
    "version": {
      "deno": "2.0.0-rc.10",
      "v8": "12.9.202.13-rusty",
      "typescript": "5.6.2"
    },
    "build": {
      "target": "aarch64-apple-darwin",
      "arch": "aarch64",
      "os": "darwin",
      "vendor": "apple",
      "env": "undefined"
    },
    "statSync": "function statSync(path) {\n  op_fs_stat_sync(pathFromURL(path), statBuf);\n  return statStruct(statBuf);\n}",
    "lstatSync": "function lstatSync(path) {\n  op_fs_lstat_sync(pathFromURL(path), statBuf);\n  return statStruct(statBuf);\n}",
    "stat": "async function stat(path) {\n  const res = await op_fs_stat_async(pathFromURL(path));\n  return parseFileInfo(res);\n}",
    "lstat": "async function lstat(path) {\n  const res = await op_fs_lstat_async(pathFromURL(path));\n  return parseFileInfo(res);\n}",
    "truncateSync": "function truncateSync(path, len) {\n  op_fs_truncate_sync(path, coerceLen(len));\n}",
    "truncate": "async function truncate(path, len) {\n  await op_fs_truncate_async(path, coerceLen(len));\n}",
    "errors": {
      "NotFound": "class NotFound extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"NotFound\";\n  }\n}",
      "PermissionDenied": "class PermissionDenied extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"PermissionDenied\";\n  }\n}",
      "ConnectionRefused": "class ConnectionRefused extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"ConnectionRefused\";\n  }\n}",
      "ConnectionReset": "class ConnectionReset extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"ConnectionReset\";\n  }\n}",
      "ConnectionAborted": "class ConnectionAborted extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"ConnectionAborted\";\n  }\n}",
      "NotConnected": "class NotConnected extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"NotConnected\";\n  }\n}",
      "AddrInUse": "class AddrInUse extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"AddrInUse\";\n  }\n}",
      "AddrNotAvailable": "class AddrNotAvailable extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"AddrNotAvailable\";\n  }\n}",
      "BrokenPipe": "class BrokenPipe extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"BrokenPipe\";\n  }\n}",
      "AlreadyExists": "class AlreadyExists extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"AlreadyExists\";\n  }\n}",
      "InvalidData": "class InvalidData extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"InvalidData\";\n  }\n}",
      "TimedOut": "class TimedOut extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"TimedOut\";\n  }\n}",
      "Interrupted": "class Interrupted extends Error {\n    constructor(msg) {\n      super(msg);\n      this.name = \"Interrupted\";\n    }\n  }",
      "WriteZero": "class WriteZero extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"WriteZero\";\n  }\n}",
      "WouldBlock": "class WouldBlock extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"WouldBlock\";\n  }\n}",
      "UnexpectedEof": "class UnexpectedEof extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"UnexpectedEof\";\n  }\n}",
      "BadResource": "class BadResource extends Error {\n    constructor(msg) {\n      super(msg);\n      this.name = \"BadResource\";\n    }\n  }",
      "Http": "class Http extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"Http\";\n  }\n}",
      "Busy": "class Busy extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"Busy\";\n  }\n}",
      "NotSupported": "class NotSupported extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"NotSupported\";\n  }\n}",
      "FilesystemLoop": "class FilesystemLoop extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"FilesystemLoop\";\n  }\n}",
      "IsADirectory": "class IsADirectory extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"IsADirectory\";\n  }\n}",
      "NetworkUnreachable": "class NetworkUnreachable extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"NetworkUnreachable\";\n  }\n}",
      "NotADirectory": "class NotADirectory extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"NotADirectory\";\n  }\n}",
      "NotCapable": "class NotCapable extends Error {\n    constructor(msg) {\n      super(msg);\n      this.name = \"NotCapable\";\n    }\n  }"
    },
    "inspect": "function inspect(\n  value,\n  inspectOptions = { __proto__: null },\n) {\n  // Default options\n  const ctx = {\n    ...getDefaultInspectOptions(),\n    ...inspectOptions,\n  };\n  if (inspectOptions.iterableLimit !== undefined) {\n    ctx.maxArrayLength = inspectOptions.iterableLimit;\n  }\n  if (inspectOptions.strAbbreviateSize !== undefined) {\n    ctx.maxStringLength = inspectOptions.strAbbreviateSize;\n  }\n\n  if (ctx.colors) ctx.stylize = createStylizeWithColor(styles, colors);\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\n  return formatValue(ctx, value, 0);\n}",
    "env": {
      "get": "function getEnv(key) {\n  return op_get_env(key) ?? undefined;\n}",
      "toObject": "toObject() {\n    return op_env();\n  }",
      "set": "function setEnv(key, value) {\n  op_set_env(key, value);\n}",
      "has": "has(key) {\n    return getEnv(key) !== undefined;\n  }",
      "delete": "function deleteEnv(key) {\n  op_delete_env(key);\n}"
    },
    "exit": "function exit(code) {\n  // Set exit code first so unload event listeners can override it.\n  if (typeof code === \"number\") {\n    op_set_exit_code(code);\n  } else {\n    code = op_get_exit_code();\n  }\n\n  // Dispatches `unload` only when it's not dispatched yet.\n  if (!globalThis[SymbolFor(\"Deno.isUnloadDispatched\")]) {\n    // Invokes the `unload` hooks before exiting\n    // ref: https://github.com/denoland/deno/issues/3603\n    windowDispatchEvent(new Event(\"unload\"));\n  }\n\n  if (exitHandler) {\n    exitHandler(code);\n    return;\n  }\n\n  op_exit();\n  throw new Error(\"Code not reachable\");\n}",
    "execPath": "function execPath() {\n  return op_exec_path();\n}",
    "SeekMode": {
      "0": "Start",
      "1": "Current",
      "2": "End",
      "Start": "0",
      "Current": "1",
      "End": "2"
    },
    "FsFile": "class FsFile {\n  #rid = 0;\n\n  #readable;\n  #writable;\n\n  constructor(rid, symbol) {\n    ObjectDefineProperty(this, internalRidSymbol, {\n      __proto__: null,\n      enumerable: false,\n      value: rid,\n    });\n    this.#rid = rid;\n    if (!symbol || symbol !== SymbolFor(\"Deno.internal.FsFile\")) {\n      throw new TypeError(\n        \"`Deno.FsFile` cannot be constructed, use `Deno.open()` or `Deno.openSync()` instead.\",\n      );\n    }\n  }\n\n  write(p) {\n    return write(this.#rid, p);\n  }\n\n  writeSync(p) {\n    return writeSync(this.#rid, p);\n  }\n\n  truncate(len) {\n    return op_fs_file_truncate_async(this.#rid, coerceLen(len));\n  }\n\n  truncateSync(len) {\n    return op_fs_ftruncate_sync(this.#rid, coerceLen(len));\n  }\n\n  read(p) {\n    return read(this.#rid, p);\n  }\n\n  readSync(p) {\n    return readSync(this.#rid, p);\n  }\n\n  seek(offset, whence) {\n    return op_fs_seek_async(this.#rid, offset, whence);\n  }\n\n  seekSync(offset, whence) {\n    return op_fs_seek_sync(this.#rid, offset, whence);\n  }\n\n  async stat() {\n    return parseFileInfo(await op_fs_file_stat_async(this.#rid));\n  }\n\n  statSync() {\n    op_fs_file_stat_sync(this.#rid, statBuf);\n    return statStruct(statBuf);\n  }\n\n  async syncData() {\n    await op_fs_file_sync_data_async(this.#rid);\n  }\n\n  syncDataSync() {\n    op_fs_file_sync_data_sync(this.#rid);\n  }\n\n  close() {\n    core.close(this.#rid);\n  }\n\n  get readable() {\n    if (this.#readable === undefined) {\n      this.#readable = readableStreamForRid(this.#rid);\n    }\n    return this.#readable;\n  }\n\n  get writable() {\n    if (this.#writable === undefined) {\n      this.#writable = writableStreamForRid(this.#rid);\n    }\n    return this.#writable;\n  }\n\n  async sync() {\n    await op_fs_file_sync_async(this.#rid);\n  }\n\n  syncSync() {\n    op_fs_file_sync_sync(this.#rid);\n  }\n\n  async utime(atime, mtime) {\n    const { 0: atimeSec, 1: atimeNsec } = toUnixTimeFromEpoch(atime);\n    const { 0: mtimeSec, 1: mtimeNsec } = toUnixTimeFromEpoch(mtime);\n    await op_fs_futime_async(\n      this.#rid,\n      atimeSec,\n      atimeNsec,\n      mtimeSec,\n      mtimeNsec,\n    );\n  }\n\n  utimeSync(atime, mtime) {\n    const { 0: atimeSec, 1: atimeNsec } = toUnixTimeFromEpoch(atime);\n    const { 0: mtimeSec, 1: mtimeNsec } = toUnixTimeFromEpoch(mtime);\n    op_fs_futime_sync(this.#rid, atimeSec, atimeNsec, mtimeSec, mtimeNsec);\n  }\n\n  isTerminal() {\n    return core.isTerminal(this.#rid);\n  }\n\n  setRaw(mode, options = { __proto__: null }) {\n    const cbreak = !!(options.cbreak ?? false);\n    op_set_raw(this.#rid, mode, cbreak);\n  }\n\n  lockSync(exclusive = false) {\n    op_fs_flock_sync(this.#rid, exclusive);\n  }\n\n  async lock(exclusive = false) {\n    await op_fs_flock_async(this.#rid, exclusive);\n  }\n\n  unlockSync() {\n    op_fs_funlock_sync(this.#rid);\n  }\n\n  async unlock() {\n    await op_fs_funlock_async(this.#rid);\n  }\n\n  [SymbolDispose]() {\n    core.tryClose(this.#rid);\n  }\n}",
    "open": "async function open(\n  path,\n  options,\n) {\n  if (options) checkOpenOptions(options);\n  const rid = await op_fs_open_async(\n    pathFromURL(path),\n    options,\n  );\n\n  return new FsFile(rid, SymbolFor(\"Deno.internal.FsFile\"));\n}",
    "openSync": "function openSync(\n  path,\n  options,\n) {\n  if (options) checkOpenOptions(options);\n  const rid = op_fs_open_sync(\n    pathFromURL(path),\n    options,\n  );\n\n  return new FsFile(rid, SymbolFor(\"Deno.internal.FsFile\"));\n}",
    "create": "function create(path) {\n  return open(path, {\n    read: true,\n    write: true,\n    truncate: true,\n    create: true,\n  });\n}",
    "createSync": "function createSync(path) {\n  return openSync(path, {\n    read: true,\n    write: true,\n    truncate: true,\n    create: true,\n  });\n}",
    "stdin": {},
    "stdout": {},
    "stderr": {},
    "connect": "async function connect(args) {\n  switch (args.transport ?? \"tcp\") {\n    case \"tcp\": {\n      const port = validatePort(args.port);\n      const { 0: rid, 1: localAddr, 2: remoteAddr } = await op_net_connect_tcp(\n        {\n          hostname: args.hostname ?? \"127.0.0.1\",\n          port,\n        },\n      );\n      localAddr.transport = \"tcp\";\n      remoteAddr.transport = \"tcp\";\n      return new TcpConn(rid, remoteAddr, localAddr);\n    }\n    case \"unix\": {\n      const { 0: rid, 1: localAddr, 2: remoteAddr } = await op_net_connect_unix(\n        args.path,\n      );\n      return new UnixConn(\n        rid,\n        { transport: \"unix\", path: remoteAddr },\n        { transport: \"unix\", path: localAddr },\n      );\n    }\n    default:\n      throw new TypeError(`Unsupported transport: '${transport}'`);\n  }\n}",
    "listen": "function listen(args) {\n  switch (args.transport ?? \"tcp\") {\n    case \"tcp\": {\n      const port = validatePort(args.port);\n      const { 0: rid, 1: addr } = op_net_listen_tcp(\n        {\n          hostname: args.hostname ?? \"0.0.0.0\",\n          port,\n        },\n        args.reusePort,\n        args.loadBalanced ?? false,\n      );\n      addr.transport = \"tcp\";\n      return new Listener(rid, addr);\n    }\n    case \"unix\": {\n      const { 0: rid, 1: path } = op_net_listen_unix(\n        args.path,\n        args[listenOptionApiName] ?? \"Deno.listen\",\n      );\n      const addr = {\n        transport: \"unix\",\n        path,\n      };\n      return new Listener(rid, addr);\n    }\n    default:\n      throw new TypeError(`Unsupported transport: '${transport}'`);\n  }\n}",
    "loadavg": "function loadavg() {\n  return op_loadavg();\n}",
    "connectTls": "async function connectTls({\n  port,\n  hostname = \"127.0.0.1\",\n  transport = \"tcp\",\n  caCerts = [],\n  alpnProtocols = undefined,\n  keyFormat = undefined,\n  cert = undefined,\n  key = undefined,\n}) {\n  if (transport !== \"tcp\") {\n    throw new TypeError(`Unsupported transport: '${transport}'`);\n  }\n\n  const keyPair = loadTlsKeyPair(\"Deno.connectTls\", {\n    keyFormat,\n    cert,\n    key,\n  });\n  // TODO(mmastrac): We only expose this feature via symbol for now. This should actually be a feature\n  // in Deno.connectTls, however.\n  const serverName = arguments[0][serverNameSymbol] ?? null;\n  const { 0: rid, 1: localAddr, 2: remoteAddr } = await op_net_connect_tls(\n    { hostname, port },\n    { caCerts, alpnProtocols, serverName },\n    keyPair,\n  );\n  localAddr.transport = \"tcp\";\n  remoteAddr.transport = \"tcp\";\n  return new TlsConn(rid, remoteAddr, localAddr);\n}",
    "listenTls": "function listenTls({\n  port,\n  hostname = \"0.0.0.0\",\n  transport = \"tcp\",\n  alpnProtocols = undefined,\n  reusePort = false,\n}) {\n  if (transport !== \"tcp\") {\n    throw new TypeError(`Unsupported transport: '${transport}'`);\n  }\n  port = validatePort(port);\n\n  if (!hasTlsKeyPairOptions(arguments[0])) {\n    throw new TypeError(\n      \"A key and certificate are required for `Deno.listenTls`\",\n    );\n  }\n  const keyPair = loadTlsKeyPair(\"Deno.listenTls\", arguments[0]);\n  const { 0: rid, 1: localAddr } = op_net_listen_tls(\n    { hostname, port },\n    { alpnProtocols, reusePort },\n    keyPair,\n  );\n  return new TlsListener(rid, localAddr);\n}",
    "startTls": "async function startTls(\n  conn,\n  {\n    hostname = \"127.0.0.1\",\n    caCerts = [],\n    alpnProtocols = undefined,\n  } = { __proto__: null },\n) {\n  const { 0: rid, 1: localAddr, 2: remoteAddr } = op_tls_start({\n    rid: conn[internalRidSymbol],\n    hostname,\n    caCerts,\n    alpnProtocols,\n  });\n  return new TlsConn(rid, remoteAddr, localAddr);\n}",
    "symlink": "async function symlink(\n  oldpath,\n  newpath,\n  options,\n) {\n  await op_fs_symlink_async(\n    pathFromURL(oldpath),\n    pathFromURL(newpath),\n    options?.type,\n  );\n}",
    "symlinkSync": "function symlinkSync(\n  oldpath,\n  newpath,\n  options,\n) {\n  op_fs_symlink_sync(\n    pathFromURL(oldpath),\n    pathFromURL(newpath),\n    options?.type,\n  );\n}",
    "link": "async function link(oldpath, newpath) {\n  await op_fs_link_async(oldpath, newpath);\n}",
    "linkSync": "function linkSync(oldpath, newpath) {\n  op_fs_link_sync(oldpath, newpath);\n}",
    "permissions": {},
    "Permissions": "class Permissions {\n  constructor(key = null) {\n    if (key != illegalConstructorKey) {\n      throw new TypeError(\"Illegal constructor\");\n    }\n  }\n\n  query(desc) {\n    try {\n      return PromiseResolve(this.querySync(desc));\n    } catch (error) {\n      return PromiseReject(error);\n    }\n  }\n\n  querySync(desc) {\n    if (!isValidDescriptor(desc)) {\n      throw new TypeError(\n        `The provided value \"${desc?.name}\" is not a valid permission name`,\n      );\n    }\n\n    formDescriptor(desc);\n\n    const status = opQuery(desc);\n    return cache(desc, status);\n  }\n\n  revoke(desc) {\n    try {\n      return PromiseResolve(this.revokeSync(desc));\n    } catch (error) {\n      return PromiseReject(error);\n    }\n  }\n\n  revokeSync(desc) {\n    if (!isValidDescriptor(desc)) {\n      throw new TypeError(\n        `The provided value \"${desc?.name}\" is not a valid permission name`,\n      );\n    }\n\n    formDescriptor(desc);\n\n    const status = opRevoke(desc);\n    return cache(desc, status);\n  }\n\n  request(desc) {\n    try {\n      return PromiseResolve(this.requestSync(desc));\n    } catch (error) {\n      return PromiseReject(error);\n    }\n  }\n\n  requestSync(desc) {\n    if (!isValidDescriptor(desc)) {\n      throw new TypeError(\n        `The provided value \"${desc?.name}\" is not a valid permission name.`,\n      );\n    }\n\n    formDescriptor(desc);\n\n    const status = opRequest(desc);\n    return cache(desc, status);\n  }\n}",
    "PermissionStatus": "class PermissionStatus extends EventTarget {\n  /** @type {{ state: Deno.PermissionState, partial: boolean }} */\n  #status;\n\n  /** @type {((this: PermissionStatus, event: Event) => any) | null} */\n  onchange = null;\n\n  /** @returns {Deno.PermissionState} */\n  get state() {\n    return this.#status.state;\n  }\n\n  /** @returns {boolean} */\n  get partial() {\n    return this.#status.partial;\n  }\n\n  /**\n   * @param {{ state: Deno.PermissionState, partial: boolean }} status\n   * @param {unknown} key\n   */\n  constructor(status = null, key = null) {\n    if (key != illegalConstructorKey) {\n      throw new TypeError(\"Illegal constructor\");\n    }\n    super();\n    this.#status = status;\n  }\n\n  /**\n   * @param {Event} event\n   * @returns {boolean}\n   */\n  dispatchEvent(event) {\n    let dispatched = super.dispatchEvent(event);\n    if (dispatched && this.onchange) {\n      FunctionPrototypeCall(this.onchange, this, event);\n      dispatched = !event.defaultPrevented;\n    }\n    return dispatched;\n  }\n\n  [SymbolFor(\"Deno.privateCustomInspect\")](inspect, inspectOptions) {\n    const object = { state: this.state, onchange: this.onchange };\n    if (this.partial) object.partial = this.partial;\n    return `${this.constructor.name} ${inspect(object, inspectOptions)}`;\n  }\n}",
    "serveHttp": "function serveHttp(conn) {\n  const rid = op_http_start(conn[internalRidSymbol]);\n  return new HttpConn(rid, conn.remoteAddr, conn.localAddr);\n}",
    "serve": "function serve(arg1, arg2) {\n  let options;\n  let handler;\n  if (typeof arg1 === \"function\") {\n    handler = arg1;\n  } else if (typeof arg2 === \"function\") {\n    handler = arg2;\n    options = arg1;\n  } else {\n    options = arg1;\n  }\n  if (handler === undefined) {\n    if (options === undefined) {\n      throw new TypeError(\"Cannot serve HTTP requests: either a `handler` or `options` must be specified\");\n    }\n    handler = options.handler;\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(`Cannot serve HTTP requests: handler must be a function, received ${typeof handler}`);\n  }\n  if (options === undefined) {\n    options = {\n      __proto__: null\n    };\n  }\n  const wantsHttps = hasTlsKeyPairOptions(options);\n  const wantsUnix = ObjectHasOwn(options, \"path\");\n  const signal = options.signal;\n  const onError = options.onError ?? function(error) {\n    // deno-lint-ignore no-console\n    console.error(error);\n    return internalServerError();\n  };\n  if (wantsUnix) {\n    const listener = listen({\n      transport: \"unix\",\n      path: options.path,\n      [listenOptionApiName]: \"Deno.serve\"\n    });\n    const path = listener.addr.path;\n    return serveHttpOnListener(listener, signal, handler, onError, ()=>{\n      if (options.onListen) {\n        options.onListen(listener.addr);\n      } else {\n        // deno-lint-ignore no-console\n        console.error(`Listening on ${path}`);\n      }\n    });\n  }\n  const listenOpts = {\n    hostname: options.hostname ?? \"0.0.0.0\",\n    port: options.port ?? 8000,\n    reusePort: options.reusePort ?? false,\n    loadBalanced: options[kLoadBalanced] ?? false\n  };\n  if (options.certFile || options.keyFile) {\n    throw new TypeError(\"Unsupported 'certFile' / 'keyFile' options provided: use 'cert' / 'key' instead.\");\n  }\n  if (options.alpnProtocols) {\n    throw new TypeError(\"Unsupported 'alpnProtocols' option provided. 'h2' and 'http/1.1' are automatically supported.\");\n  }\n  let listener;\n  if (wantsHttps) {\n    if (!options.cert || !options.key) {\n      throw new TypeError(\"Both 'cert' and 'key' must be provided to enable HTTPS\");\n    }\n    listenOpts.cert = options.cert;\n    listenOpts.key = options.key;\n    listenOpts.alpnProtocols = [\n      \"h2\",\n      \"http/1.1\"\n    ];\n    listener = listenTls(listenOpts);\n    listenOpts.port = listener.addr.port;\n  } else {\n    listener = listen(listenOpts);\n    listenOpts.port = listener.addr.port;\n  }\n  const addr = listener.addr;\n  const onListen = (scheme)=>{\n    if (options.onListen) {\n      options.onListen(addr);\n    } else {\n      const host = formatHostName(addr.hostname);\n      // deno-lint-ignore no-console\n      console.error(`Listening on ${scheme}${host}:${addr.port}/`);\n    }\n  };\n  return serveHttpOnListener(listener, signal, handler, onError, onListen);\n}",
    "resolveDns": "async function resolveDns(query, recordType, options) {\n  let cancelRid;\n  let abortHandler;\n  if (options?.signal) {\n    options.signal.throwIfAborted();\n    cancelRid = createCancelHandle();\n    abortHandler = () => core.tryClose(cancelRid);\n    options.signal[abortSignal.add](abortHandler);\n  }\n\n  try {\n    return await op_dns_resolve({\n      cancelRid,\n      query,\n      recordType,\n      options,\n    });\n  } finally {\n    if (options?.signal) {\n      options.signal[abortSignal.remove](abortHandler);\n\n      // always throw the abort error when aborted\n      options.signal.throwIfAborted();\n    }\n  }\n}",
    "upgradeWebSocket": "function upgradeWebSocket(request, options = {\n  __proto__: null\n}) {\n  const inner = toInnerRequest(request);\n  const upgrade = request.headers.get(\"upgrade\");\n  const upgradeHasWebSocketOption = upgrade !== null && websocketCvf(upgrade);\n  if (!upgradeHasWebSocketOption) {\n    throw new TypeError(\"Invalid Header: 'upgrade' header must contain 'websocket'\");\n  }\n  const connection = request.headers.get(\"connection\");\n  const connectionHasUpgradeOption = connection !== null && upgradeCvf(connection);\n  if (!connectionHasUpgradeOption) {\n    throw new TypeError(\"Invalid Header: 'connection' header must contain 'Upgrade'\");\n  }\n  const websocketKey = request.headers.get(\"sec-websocket-key\");\n  if (websocketKey === null) {\n    throw new TypeError(\"Invalid Header: 'sec-websocket-key' header must be set\");\n  }\n  const accept = op_http_websocket_accept_header(websocketKey);\n  const r = newInnerResponse(101);\n  r.headerList = [\n    [\n      \"upgrade\",\n      \"websocket\"\n    ],\n    [\n      \"connection\",\n      \"Upgrade\"\n    ],\n    [\n      \"sec-websocket-accept\",\n      accept\n    ]\n  ];\n  const protocolsStr = request.headers.get(\"sec-websocket-protocol\") || \"\";\n  const protocols = StringPrototypeSplit(protocolsStr, \", \");\n  if (protocols && options.protocol) {\n    if (ArrayPrototypeIncludes(protocols, options.protocol)) {\n      ArrayPrototypePush(r.headerList, [\n        \"sec-websocket-protocol\",\n        options.protocol\n      ]);\n    } else {\n      throw new TypeError(`Protocol '${options.protocol}' not in the request's protocol list (non negotiable)`);\n    }\n  }\n  const socket = createWebSocketBranded(WebSocket);\n  setEventTargetData(socket);\n  socket[_server] = true;\n  // Nginx timeout is 60s, so default to a lower number: https://github.com/denoland/deno/pull/23985\n  socket[_idleTimeoutDuration] = options.idleTimeout ?? 30;\n  socket[_idleTimeoutTimeout] = null;\n  if (inner._wantsUpgrade) {\n    return inner._wantsUpgrade(\"upgradeWebSocket\", r, socket);\n  }\n  const response = fromInnerResponse(r, \"immutable\");\n  response[_ws] = socket;\n  return {\n    response,\n    socket\n  };\n}",
    "utime": "async function utime(\n  path,\n  atime,\n  mtime,\n) {\n  const { 0: atimeSec, 1: atimeNsec } = toUnixTimeFromEpoch(atime);\n  const { 0: mtimeSec, 1: mtimeNsec } = toUnixTimeFromEpoch(mtime);\n  await op_fs_utime_async(\n    pathFromURL(path),\n    atimeSec,\n    atimeNsec,\n    mtimeSec,\n    mtimeNsec,\n  );\n}",
    "utimeSync": "function utimeSync(\n  path,\n  atime,\n  mtime,\n) {\n  const { 0: atimeSec, 1: atimeNsec } = toUnixTimeFromEpoch(atime);\n  const { 0: mtimeSec, 1: mtimeNsec } = toUnixTimeFromEpoch(mtime);\n  op_fs_utime_sync(\n    pathFromURL(path),\n    atimeSec,\n    atimeNsec,\n    mtimeSec,\n    mtimeNsec,\n  );\n}",
    "kill": "function kill(pid, signo = \"SIGTERM\") {\n  opKill(pid, signo, \"Deno.kill()\");\n}",
    "addSignalListener": "function addSignalListener(signo, listener) {\n  checkSignalListenerType(listener);\n\n  const sigData = getSignalData(signo);\n  SetPrototypeAdd(sigData.listeners, listener);\n\n  if (!sigData.rid) {\n    // If signal resource doesn't exist, create it.\n    // The program starts listening to the signal\n    sigData.rid = bindSignal(signo);\n    loop(sigData);\n  }\n}",
    "removeSignalListener": "function removeSignalListener(signo, listener) {\n  checkSignalListenerType(listener);\n\n  const sigData = getSignalData(signo);\n  SetPrototypeDelete(sigData.listeners, listener);\n\n  if (sigData.listeners.size === 0 && sigData.rid) {\n    unbindSignal(sigData.rid);\n    sigData.rid = undefined;\n  }\n}",
    "refTimer": "function refTimer(id) {\n  core.refTimer(id);\n}",
    "unrefTimer": "function unrefTimer(id) {\n  core.unrefTimer(id);\n}",
    "osRelease": "function osRelease() {\n  return op_os_release();\n}",
    "osUptime": "function osUptime() {\n  return op_os_uptime();\n}",
    "hostname": "function hostname() {\n  return op_hostname();\n}",
    "systemMemoryInfo": "function systemMemoryInfo() {\n  return op_system_memory_info();\n}",
    "networkInterfaces": "function networkInterfaces() {\n  return op_network_interfaces();\n}",
    "consoleSize": "function consoleSize() {\n  op_console_size(size);\n  return { columns: size[0], rows: size[1] };\n}",
    "gid": "function gid() {\n  return op_gid();\n}",
    "uid": "function uid() {\n  return op_uid();\n}",
    "Command": "class Command {\n  #command;\n  #options;\n\n  constructor(command, options) {\n    this.#command = command;\n    this.#options = options;\n  }\n\n  output() {\n    if (this.#options?.stdin === \"piped\") {\n      throw new TypeError(\n        \"Piped stdin is not supported for this function, use 'Deno.Command.spawn()' instead\",\n      );\n    }\n    return spawn(this.#command, this.#options);\n  }\n\n  outputSync() {\n    if (this.#options?.stdin === \"piped\") {\n      throw new TypeError(\n        \"Piped stdin is not supported for this function, use 'Deno.Command.spawn()' instead\",\n      );\n    }\n    return spawnSync(this.#command, this.#options);\n  }\n\n  spawn() {\n    const options = {\n      __proto__: null,\n      ...(this.#options ?? {}),\n      stdout: this.#options?.stdout ?? \"inherit\",\n      stderr: this.#options?.stderr ?? \"inherit\",\n      stdin: this.#options?.stdin ?? \"inherit\",\n    };\n    return spawnChild(this.#command, options);\n  }\n}",
    "ChildProcess": "class ChildProcess {\n  #rid;\n  #waitPromise;\n  #waitComplete = false;\n\n  [_ipcPipeRid];\n  [_extraPipeRids];\n\n  #pid;\n  get pid() {\n    return this.#pid;\n  }\n\n  #stdin = null;\n  get stdin() {\n    if (this.#stdin == null) {\n      throw new TypeError(\"Cannot get 'stdin': 'stdin' is not piped\");\n    }\n    return this.#stdin;\n  }\n\n  #stdout = null;\n  get stdout() {\n    if (this.#stdout == null) {\n      throw new TypeError(\"Cannot get 'stdout': 'stdout' is not piped\");\n    }\n    return this.#stdout;\n  }\n\n  #stderr = null;\n  get stderr() {\n    if (this.#stderr == null) {\n      throw new TypeError(\"Cannot get 'stderr': 'stderr' is not piped\");\n    }\n    return this.#stderr;\n  }\n\n  constructor(key = null, {\n    signal,\n    rid,\n    pid,\n    stdinRid,\n    stdoutRid,\n    stderrRid,\n    ipcPipeRid, // internal\n    extraPipeRids,\n  } = null) {\n    if (key !== illegalConstructorKey) {\n      throw new TypeError(\"Illegal constructor\");\n    }\n\n    this.#rid = rid;\n    this.#pid = pid;\n    this[_ipcPipeRid] = ipcPipeRid;\n    this[_extraPipeRids] = extraPipeRids;\n\n    if (stdinRid !== null) {\n      this.#stdin = writableStreamForRid(stdinRid);\n    }\n\n    if (stdoutRid !== null) {\n      this.#stdout = readableStreamForRidUnrefable(stdoutRid);\n    }\n\n    if (stderrRid !== null) {\n      this.#stderr = readableStreamForRidUnrefable(stderrRid);\n    }\n\n    const onAbort = () => this.kill(\"SIGTERM\");\n    signal?.[abortSignal.add](onAbort);\n\n    const waitPromise = op_spawn_wait(this.#rid);\n    this.#waitPromise = waitPromise;\n    this.#status = PromisePrototypeThen(waitPromise, (res) => {\n      signal?.[abortSignal.remove](onAbort);\n      this.#waitComplete = true;\n      return res;\n    });\n  }\n\n  #status;\n  get status() {\n    return this.#status;\n  }\n\n  async output() {\n    if (this.#stdout?.locked) {\n      throw new TypeError(\n        \"Cannot collect output: 'stdout' is locked\",\n      );\n    }\n    if (this.#stderr?.locked) {\n      throw new TypeError(\n        \"Cannot collect output: 'stderr' is locked\",\n      );\n    }\n\n    const { 0: status, 1: stdout, 2: stderr } = await SafePromiseAll([\n      this.#status,\n      collectOutput(this.#stdout),\n      collectOutput(this.#stderr),\n    ]);\n\n    return {\n      success: status.success,\n      code: status.code,\n      signal: status.signal,\n      get stdout() {\n        if (stdout == null) {\n          throw new TypeError(\"Cannot get 'stdout': 'stdout' is not piped\");\n        }\n        return stdout;\n      },\n      get stderr() {\n        if (stderr == null) {\n          throw new TypeError(\"Cannot get 'stderr': 'stderr' is not piped\");\n        }\n        return stderr;\n      },\n    };\n  }\n\n  kill(signo = \"SIGTERM\") {\n    if (this.#waitComplete) {\n      throw new TypeError(\"Child process has already terminated\");\n    }\n    op_spawn_kill(this.#rid, signo);\n  }\n\n  async [SymbolAsyncDispose]() {\n    try {\n      op_spawn_kill(this.#rid, \"SIGTERM\");\n    } catch {\n      // ignore errors from killing the process (such as ESRCH or BadResource)\n    }\n    await this.#status;\n  }\n\n  ref() {\n    core.refOpPromise(this.#waitPromise);\n    if (this.#stdout) readableStreamForRidUnrefableRef(this.#stdout);\n    if (this.#stderr) readableStreamForRidUnrefableRef(this.#stderr);\n  }\n\n  unref() {\n    core.unrefOpPromise(this.#waitPromise);\n    if (this.#stdout) readableStreamForRidUnrefableUnref(this.#stdout);\n    if (this.#stderr) readableStreamForRidUnrefableUnref(this.#stderr);\n  }\n}",
    "dlopen": "function dlopen(path, symbols) {\n  return new DynamicLibrary(pathFromURL(path), symbols);\n}",
    "UnsafeCallback": "class UnsafeCallback {\n  #refcount;\n  // Internal promise only meant to keep Deno from exiting\n  #refpromise;\n  #rid;\n  definition;\n  callback;\n  pointer;\n\n  constructor(definition, callback) {\n    if (definition.nonblocking) {\n      throw new TypeError(\n        \"Cannot construct UnsafeCallback: cannot be nonblocking\",\n      );\n    }\n    const { 0: rid, 1: pointer } = op_ffi_unsafe_callback_create(\n      definition,\n      callback,\n    );\n    this.#refcount = 0;\n    this.#rid = rid;\n    this.pointer = pointer;\n    this.definition = definition;\n    this.callback = callback;\n  }\n\n  static threadSafe(definition, callback) {\n    const unsafeCallback = new UnsafeCallback(definition, callback);\n    unsafeCallback.ref();\n    return unsafeCallback;\n  }\n\n  ref() {\n    if (this.#refcount++ === 0) {\n      if (this.#refpromise) {\n        // Re-refing\n        core.refOpPromise(this.#refpromise);\n      } else {\n        this.#refpromise = op_ffi_unsafe_callback_ref(\n          this.#rid,\n        );\n      }\n    }\n    return this.#refcount;\n  }\n\n  unref() {\n    // Only decrement refcount if it is positive, and only\n    // unref the callback if refcount reaches zero.\n    if (this.#refcount > 0 && --this.#refcount === 0) {\n      core.unrefOpPromise(this.#refpromise);\n    }\n    return this.#refcount;\n  }\n\n  close() {\n    this.#refcount = 0;\n    op_ffi_unsafe_callback_close(this.#rid);\n  }\n}",
    "UnsafePointer": "class UnsafePointer {\n  static create(value) {\n    return op_ffi_ptr_create(value);\n  }\n\n  static equals(a, b) {\n    if (a === null || b === null) {\n      return a === b;\n    }\n    return op_ffi_ptr_equals(a, b);\n  }\n\n  static of(value) {\n    if (ObjectPrototypeIsPrototypeOf(UnsafeCallbackPrototype, value)) {\n      return value.pointer;\n    }\n    let pointer;\n    if (ArrayBufferIsView(value)) {\n      if (value.length === 0) {\n        pointer = op_ffi_ptr_of_exact(value);\n      } else {\n        pointer = op_ffi_ptr_of(value);\n      }\n    } else if (isArrayBuffer(value)) {\n      if (value.length === 0) {\n        pointer = op_ffi_ptr_of_exact(new Uint8Array(value));\n      } else {\n        pointer = op_ffi_ptr_of(new Uint8Array(value));\n      }\n    } else {\n      throw new TypeError(\n        `Cannot access pointer: expected 'ArrayBuffer', 'ArrayBufferView' or 'UnsafeCallbackPrototype', received ${typeof value}`,\n      );\n    }\n    if (pointer) {\n      POINTER_TO_BUFFER_WEAK_MAP.set(pointer, value);\n    }\n    return pointer;\n  }\n\n  static offset(value, offset) {\n    return op_ffi_ptr_offset(value, offset);\n  }\n\n  static value(value) {\n    if (ObjectPrototypeIsPrototypeOf(UnsafeCallbackPrototype, value)) {\n      value = value.pointer;\n    }\n    return op_ffi_ptr_value(value);\n  }\n}",
    "UnsafePointerView": "class UnsafePointerView {\n  pointer;\n\n  constructor(pointer) {\n    this.pointer = pointer;\n  }\n\n  getBool(offset = 0) {\n    return op_ffi_read_bool(\n      this.pointer,\n      offset,\n    );\n  }\n\n  getUint8(offset = 0) {\n    return op_ffi_read_u8(\n      this.pointer,\n      offset,\n    );\n  }\n\n  getInt8(offset = 0) {\n    return op_ffi_read_i8(\n      this.pointer,\n      offset,\n    );\n  }\n\n  getUint16(offset = 0) {\n    return op_ffi_read_u16(\n      this.pointer,\n      offset,\n    );\n  }\n\n  getInt16(offset = 0) {\n    return op_ffi_read_i16(\n      this.pointer,\n      offset,\n    );\n  }\n\n  getUint32(offset = 0) {\n    return op_ffi_read_u32(\n      this.pointer,\n      offset,\n    );\n  }\n\n  getInt32(offset = 0) {\n    return op_ffi_read_i32(\n      this.pointer,\n      offset,\n    );\n  }\n\n  getBigUint64(offset = 0) {\n    return op_ffi_read_u64(\n      this.pointer,\n      // We return a BigInt, so the turbocall\n      // is forced to use BigInts everywhere.\n      BigInt(offset),\n    );\n  }\n\n  getBigInt64(offset = 0) {\n    return op_ffi_read_i64(\n      this.pointer,\n      // We return a BigInt, so the turbocall\n      // is forced to use BigInts everywhere.\n      BigInt(offset),\n    );\n  }\n\n  getFloat32(offset = 0) {\n    return op_ffi_read_f32(\n      this.pointer,\n      offset,\n    );\n  }\n\n  getFloat64(offset = 0) {\n    return op_ffi_read_f64(\n      this.pointer,\n      offset,\n    );\n  }\n\n  getPointer(offset = 0) {\n    return op_ffi_read_ptr(\n      this.pointer,\n      offset,\n    );\n  }\n\n  getCString(offset = 0) {\n    return op_ffi_cstr_read(\n      this.pointer,\n      offset,\n    );\n  }\n\n  static getCString(pointer, offset = 0) {\n    return op_ffi_cstr_read(\n      pointer,\n      offset,\n    );\n  }\n\n  getArrayBuffer(byteLength, offset = 0) {\n    return op_ffi_get_buf(\n      this.pointer,\n      offset,\n      byteLength,\n    );\n  }\n\n  static getArrayBuffer(pointer, byteLength, offset = 0) {\n    return op_ffi_get_buf(\n      pointer,\n      offset,\n      byteLength,\n    );\n  }\n\n  copyInto(destination, offset = 0) {\n    op_ffi_buf_copy_into(\n      this.pointer,\n      offset,\n      destination,\n      getBufferSourceByteLength(destination),\n    );\n  }\n\n  static copyInto(pointer, destination, offset = 0) {\n    op_ffi_buf_copy_into(\n      pointer,\n      offset,\n      destination,\n      getBufferSourceByteLength(destination),\n    );\n  }\n}",
    "UnsafeFnPointer": "class UnsafeFnPointer {\n  pointer;\n  definition;\n  #structSize;\n\n  constructor(pointer, definition) {\n    this.pointer = pointer;\n    this.definition = definition;\n    this.#structSize = isStruct(definition.result)\n      ? getTypeSizeAndAlignment(definition.result)[0]\n      : null;\n  }\n\n  call(...parameters) {\n    if (this.definition.nonblocking) {\n      if (this.#structSize === null) {\n        return op_ffi_call_ptr_nonblocking(\n          this.pointer,\n          this.definition,\n          parameters,\n        );\n      } else {\n        const buffer = new Uint8Array(this.#structSize);\n        return PromisePrototypeThen(\n          op_ffi_call_ptr_nonblocking(\n            this.pointer,\n            this.definition,\n            parameters,\n            buffer,\n          ),\n          () => buffer,\n        );\n      }\n    } else {\n      if (this.#structSize === null) {\n        return op_ffi_call_ptr(\n          this.pointer,\n          this.definition,\n          parameters,\n        );\n      } else {\n        const buffer = new Uint8Array(this.#structSize);\n        op_ffi_call_ptr(\n          this.pointer,\n          this.definition,\n          parameters,\n          buffer,\n        );\n        return buffer;\n      }\n    }\n  }\n}",
    "umask": "function umask(mask) {\n  return op_fs_umask(mask);\n}",
    "HttpClient": "class HttpClient {\n  #rid;\n\n  /**\n   * @param {number} rid\n   */\n  constructor(rid) {\n    ObjectDefineProperty(this, internalRidSymbol, {\n      __proto__: null,\n      enumerable: false,\n      value: rid,\n    });\n    this.#rid = rid;\n  }\n\n  close() {\n    core.close(this.#rid);\n  }\n\n  [SymbolDispose]() {\n    core.tryClose(this.#rid);\n  }\n}",
    "createHttpClient": "function createHttpClient(options) {\n  options.caCerts ??= [];\n  const keyPair = loadTlsKeyPair(\"Deno.createHttpClient\", options);\n  return new HttpClient(\n    op_fetch_custom_client(\n      options,\n      keyPair,\n    ),\n  );\n}",
    "test": "function test(\n  nameOrFnOrOptions,\n  optionsOrFn,\n  maybeFn,\n) {\n  return testInner(nameOrFnOrOptions, optionsOrFn, maybeFn);\n}",
    "bench": "function bench(\n  nameOrFnOrOptions,\n  optionsOrFn,\n  maybeFn,\n) {\n  // No-op if we're not running in `deno bench` subcommand.\n  if (typeof op_register_bench !== \"function\") {\n    return;\n  }\n\n  if (!registeredWarmupBench) {\n    registeredWarmupBench = true;\n    const warmupBenchDesc = {\n      name: \"<warmup>\",\n      fn: function warmup() {},\n      async: false,\n      ignore: false,\n      baseline: false,\n      only: false,\n      sanitizeExit: true,\n      permissions: null,\n      warmup: true,\n    };\n    if (cachedOrigin == undefined) {\n      cachedOrigin = op_bench_get_origin();\n    }\n    warmupBenchDesc.fn = wrapBenchmark(warmupBenchDesc);\n    op_register_bench(\n      warmupBenchDesc.fn,\n      warmupBenchDesc.name,\n      warmupBenchDesc.baseline,\n      warmupBenchDesc.group,\n      warmupBenchDesc.ignore,\n      warmupBenchDesc.only,\n      warmupBenchDesc.warmup,\n      registerBenchIdRetBufU8,\n    );\n    warmupBenchDesc.id = registerBenchIdRetBufU8[0];\n    warmupBenchDesc.origin = cachedOrigin;\n  }\n\n  let benchDesc;\n  const defaults = {\n    ignore: false,\n    baseline: false,\n    only: false,\n    sanitizeExit: true,\n    permissions: null,\n  };\n\n  if (typeof nameOrFnOrOptions === \"string\") {\n    if (!nameOrFnOrOptions) {\n      throw new TypeError(\"The bench name can't be empty\");\n    }\n    if (typeof optionsOrFn === \"function\") {\n      benchDesc = { fn: optionsOrFn, name: nameOrFnOrOptions, ...defaults };\n    } else {\n      if (!maybeFn || typeof maybeFn !== \"function\") {\n        throw new TypeError(\"Missing bench function\");\n      }\n      if (optionsOrFn.fn != undefined) {\n        throw new TypeError(\n          \"Unexpected 'fn' field in options, bench function is already provided as the third argument\",\n        );\n      }\n      if (optionsOrFn.name != undefined) {\n        throw new TypeError(\n          \"Unexpected 'name' field in options, bench name is already provided as the first argument\",\n        );\n      }\n      benchDesc = {\n        ...defaults,\n        ...optionsOrFn,\n        fn: maybeFn,\n        name: nameOrFnOrOptions,\n      };\n    }\n  } else if (typeof nameOrFnOrOptions === \"function\") {\n    if (!nameOrFnOrOptions.name) {\n      throw new TypeError(\"The bench function must have a name\");\n    }\n    if (optionsOrFn != undefined) {\n      throw new TypeError(\"Unexpected second argument to Deno.bench()\");\n    }\n    if (maybeFn != undefined) {\n      throw new TypeError(\"Unexpected third argument to Deno.bench()\");\n    }\n    benchDesc = {\n      ...defaults,\n      fn: nameOrFnOrOptions,\n      name: nameOrFnOrOptions.name,\n    };\n  } else {\n    let fn;\n    let name;\n    if (typeof optionsOrFn === \"function\") {\n      fn = optionsOrFn;\n      if (nameOrFnOrOptions.fn != undefined) {\n        throw new TypeError(\n          \"Unexpected 'fn' field in options, bench function is already provided as the second argument\",\n        );\n      }\n      name = nameOrFnOrOptions.name ?? fn.name;\n    } else {\n      if (\n        !nameOrFnOrOptions.fn || typeof nameOrFnOrOptions.fn !== \"function\"\n      ) {\n        throw new TypeError(\n          \"Expected 'fn' field in the first argument to be a bench function\",\n        );\n      }\n      fn = nameOrFnOrOptions.fn;\n      name = nameOrFnOrOptions.name ?? fn.name;\n    }\n    if (!name) {\n      throw new TypeError(\"The bench name can't be empty\");\n    }\n    benchDesc = { ...defaults, ...nameOrFnOrOptions, fn, name };\n  }\n\n  const AsyncFunction = (async () => {}).constructor;\n  benchDesc.async = AsyncFunction === benchDesc.fn.constructor;\n  benchDesc.fn = wrapBenchmark(benchDesc);\n  benchDesc.warmup = false;\n  benchDesc.name = escapeName(benchDesc.name);\n  if (cachedOrigin == undefined) {\n    cachedOrigin = op_bench_get_origin();\n  }\n  op_register_bench(\n    benchDesc.fn,\n    benchDesc.name,\n    benchDesc.baseline,\n    benchDesc.group,\n    benchDesc.ignore,\n    benchDesc.only,\n    false,\n    registerBenchIdRetBufU8,\n  );\n  benchDesc.id = registerBenchIdRetBufU8[0];\n  benchDesc.origin = cachedOrigin;\n}",
    "pid": "49634",
    "ppid": "49616",
    "noColor": "false",
    "args": {},
    "mainModule": "file:///Users/zhorton/testing/notebooks/$deno$jupyter.ts"
  }
}