{
  "DataType": "class DataType {\n    get variant() {\n        return this.constructor.name;\n    }\n    identity = \"DataType\";\n    get inner() {\n        return null;\n    }\n    equals(other) {\n        return (this.variant === other.variant &&\n            this.inner === null &&\n            other.inner === null);\n    }\n    /** Null type */\n    static get Null() {\n        return new Null();\n    }\n    /** `true` and `false`. */\n    static get Bool() {\n        return new Bool();\n    }\n    /** An `i8` */\n    static get Int8() {\n        return new Int8();\n    }\n    /** An `i16` */\n    static get Int16() {\n        return new Int16();\n    }\n    /** An `i32` */\n    static get Int32() {\n        return new Int32();\n    }\n    /** An `i64` */\n    static get Int64() {\n        return new Int64();\n    }\n    /** An `u8` */\n    static get UInt8() {\n        return new UInt8();\n    }\n    /** An `u16` */\n    static get UInt16() {\n        return new UInt16();\n    }\n    /** An `u32` */\n    static get UInt32() {\n        return new UInt32();\n    }\n    /** An `u64` */\n    static get UInt64() {\n        return new UInt64();\n    }\n    /** A `f32` */\n    static get Float32() {\n        return new Float32();\n    }\n    /** A `f64` */\n    static get Float64() {\n        return new Float64();\n    }\n    static get Date() {\n        return new Date();\n    }\n    /** Time of day type */\n    static get Time() {\n        return new Time();\n    }\n    /** Type for wrapping arbitrary JS objects */\n    static get Object() {\n        return new Object_();\n    }\n    /** A categorical encoding of a set of strings  */\n    static get Categorical() {\n        return new Categorical();\n    }\n    /** Decimal type */\n    static Decimal(precision, scale) {\n        return new Decimal(precision, scale);\n    }\n    /**\n     * Calendar date and time type\n     * @param timeUnit any of 'ms' | 'ns' | 'us'\n     * @param timeZone timezone string as defined by Intl.DateTimeFormat `America/New_York` for example.\n     */\n    static Datetime(timeUnit, timeZone = null) {\n        return new Datetime(timeUnit ?? \"ms\", timeZone);\n    }\n    /**\n     * Nested list/array type\n     *\n     * @param inner The `DataType` of values within the list\n     *\n     */\n    static List(inner) {\n        return new List(inner);\n    }\n    /**\n     * List of fixed length\n     * This is called `Array` in other polars implementations, but `Array` is widely used in JS, so we use `FixedSizeList` instead.\n     *\n     */\n    static FixedSizeList(inner, listSize) {\n        return new FixedSizeList(inner, listSize);\n    }\n    static Struct(fields) {\n        return new Struct(fields);\n    }\n    /** A variable-length UTF-8 encoded string whose offsets are represented as `i64`. */\n    static get Utf8() {\n        return new Utf8();\n    }\n    static get String() {\n        return new String();\n    }\n    toString() {\n        if (this.inner) {\n            return `${this.identity}(${this.variant}(${this.inner}))`;\n        }\n        return `${this.identity}(${this.variant})`;\n    }\n    toJSON() {\n        const inner = this.inner;\n        if (inner) {\n            return {\n                [this.identity]: {\n                    [this.variant]: inner[0],\n                },\n            };\n        }\n        return {\n            [this.identity]: this.variant,\n        };\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.toString();\n    }\n    asFixedSizeList() {\n        if (this instanceof FixedSizeList) {\n            return this;\n        }\n        return null;\n    }\n}",
  "pl": {
    "Expr": "(_expr) => {\n    const unwrap = (method, ...args) => {\n        return _expr[method](...args);\n    };\n    const wrap = (method, ...args) => {\n        return (0, exports._Expr)(unwrap(method, ...args));\n    };\n    const wrapExprArg = (method, lit = false) => (other) => {\n        const expr = (0, exports.exprToLitOrExpr)(other, lit).inner();\n        return wrap(method, expr);\n    };\n    const rolling = (method) => (opts, weights, minPeriods, center) => {\n        const windowSize = opts?.[\"windowSize\"] ?? (typeof opts === \"number\" ? opts : null);\n        if (windowSize === null) {\n            throw new Error(\"window size is required\");\n        }\n        const callOpts = {\n            windowSize: windowSize,\n            weights: opts?.[\"weights\"] ?? weights,\n            minPeriods: opts?.[\"minPeriods\"] ?? minPeriods ?? windowSize,\n            center: opts?.[\"center\"] ?? center ?? false,\n        };\n        return wrap(method, callOpts);\n    };\n    return {\n        _expr,\n        [Symbol.toStringTag]() {\n            return \"Expr\";\n        },\n        [utils_1.INSPECT_SYMBOL]() {\n            return _expr.toString();\n        },\n        serialize(format) {\n            return _expr.serialize(format);\n        },\n        toString() {\n            return _expr.toString();\n        },\n        toJSON(...args) {\n            // this is passed by `JSON.stringify` when calling `toJSON()`\n            if (args[0] === \"\") {\n                return _expr.toJs();\n            }\n            return _expr.serialize(\"json\").toString();\n        },\n        get str() {\n            return str.ExprStringFunctions(_expr);\n        },\n        get lst() {\n            return lst.ExprListFunctions(_expr);\n        },\n        get date() {\n            return dt.ExprDateTimeFunctions(_expr);\n        },\n        get struct() {\n            return struct.ExprStructFunctions(_expr);\n        },\n        abs() {\n            return (0, exports._Expr)(_expr.abs());\n        },\n        aggGroups() {\n            return (0, exports._Expr)(_expr.aggGroups());\n        },\n        alias(name) {\n            return (0, exports._Expr)(_expr.alias(name));\n        },\n        inner() {\n            return _expr;\n        },\n        and(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other, false).inner();\n            return (0, exports._Expr)(_expr.and(expr));\n        },\n        arccos() {\n            return (0, exports._Expr)(_expr.arccos());\n        },\n        arccosh() {\n            return (0, exports._Expr)(_expr.arccosh());\n        },\n        arcsin() {\n            return (0, exports._Expr)(_expr.arcsin());\n        },\n        arcsinh() {\n            return (0, exports._Expr)(_expr.arcsinh());\n        },\n        arctan() {\n            return (0, exports._Expr)(_expr.arctan());\n        },\n        arctanh() {\n            return (0, exports._Expr)(_expr.arctanh());\n        },\n        argMax() {\n            return (0, exports._Expr)(_expr.argMax());\n        },\n        argMin() {\n            return (0, exports._Expr)(_expr.argMin());\n        },\n        argSort(reverse = false, maintain_order) {\n            reverse = reverse?.reverse ?? reverse;\n            maintain_order = reverse?.maintain_order ?? maintain_order;\n            return (0, exports._Expr)(_expr.argSort(reverse, false, false, maintain_order));\n        },\n        argUnique() {\n            return (0, exports._Expr)(_expr.argUnique());\n        },\n        as(name) {\n            return (0, exports._Expr)(_expr.alias(name));\n        },\n        backwardFill() {\n            return (0, exports._Expr)(_expr.backwardFill());\n        },\n        cast(dtype, strict = false) {\n            return (0, exports._Expr)(_expr.cast(dtype, strict));\n        },\n        ceil() {\n            return (0, exports._Expr)(_expr.ceil());\n        },\n        clip(arg, max) {\n            if (typeof arg === \"number\") {\n                return (0, exports._Expr)(_expr.clip((0, exports.exprToLitOrExpr)(arg)._expr, (0, exports.exprToLitOrExpr)(max)._expr));\n            }\n            return (0, exports._Expr)(_expr.clip((0, exports.exprToLitOrExpr)(arg.min)._expr, (0, exports.exprToLitOrExpr)(arg.max)._expr));\n        },\n        cos() {\n            return (0, exports._Expr)(_expr.cos());\n        },\n        cosh() {\n            return (0, exports._Expr)(_expr.cosh());\n        },\n        cot() {\n            return (0, exports._Expr)(_expr.cot());\n        },\n        count() {\n            return (0, exports._Expr)(_expr.count());\n        },\n        cumCount(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumCount(reverse?.reverse ?? reverse));\n        },\n        cumMax(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumMax(reverse));\n        },\n        cumMin(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumMin(reverse));\n        },\n        cumProd(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumProd(reverse));\n        },\n        cumSum(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumSum(reverse));\n        },\n        diff(n, nullBehavior = \"ignore\") {\n            if (typeof n === \"number\") {\n                return (0, exports._Expr)(_expr.diff(n, nullBehavior));\n            }\n            return (0, exports._Expr)(_expr.diff(n.n, n.nullBehavior));\n        },\n        dot(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other, false).inner();\n            return (0, exports._Expr)(_expr.dot(expr));\n        },\n        ewmMean(opts, adjust, minPeriods, bias, ignoreNulls) {\n            if (opts) {\n                if (typeof opts === \"number\") {\n                    return wrap(\"ewmMean\", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);\n                }\n                return wrap(\"ewmMean\", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);\n            }\n            return wrap(\"ewmMean\", 0.5, true, 1, false, true);\n        },\n        ewmStd(opts, adjust, minPeriods, bias, ignoreNulls) {\n            if (opts) {\n                if (typeof opts === \"number\") {\n                    return wrap(\"ewmStd\", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);\n                }\n                return wrap(\"ewmStd\", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);\n            }\n            return wrap(\"ewmStd\", 0.5, true, 1, false, true);\n        },\n        ewmVar(opts, adjust, minPeriods, bias, ignoreNulls) {\n            if (opts) {\n                if (typeof opts === \"number\") {\n                    return wrap(\"ewmVar\", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);\n                }\n                return wrap(\"ewmVar\", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);\n            }\n            return wrap(\"ewmVar\", 0.5, true, 1, false, true);\n        },\n        exclude(...columns) {\n            return (0, exports._Expr)(_expr.exclude(columns.flat(2)));\n        },\n        explode() {\n            return (0, exports._Expr)(_expr.explode());\n        },\n        exp() {\n            return (0, exports._Expr)(_expr.exp());\n        },\n        extend(o, n) {\n            if (n !== null && typeof n === \"number\") {\n                return (0, exports._Expr)(_expr.extendConstant(o, n));\n            }\n            return (0, exports._Expr)(_expr.extendConstant(o.value, o.n));\n        },\n        extendConstant(o, n) {\n            if (n !== null && typeof n === \"number\") {\n                return (0, exports._Expr)(_expr.extendConstant(o, n));\n            }\n            return (0, exports._Expr)(_expr.extendConstant(o.value, o.n));\n        },\n        fillNan(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other, true).inner();\n            return (0, exports._Expr)(_expr.fillNan(expr));\n        },\n        fillNull(fillValue) {\n            if ([\"backward\", \"forward\", \"mean\", \"min\", \"max\", \"zero\", \"one\"].includes(fillValue)) {\n                return (0, exports._Expr)(_expr.fillNullWithStrategy(fillValue));\n            }\n            const expr = (0, exports.exprToLitOrExpr)(fillValue).inner();\n            return (0, exports._Expr)(_expr.fillNull(expr));\n        },\n        filter(predicate) {\n            const expr = (0, exports.exprToLitOrExpr)(predicate).inner();\n            return (0, exports._Expr)(_expr.filter(expr));\n        },\n        first() {\n            return (0, exports._Expr)(_expr.first());\n        },\n        flatten() {\n            return (0, exports._Expr)(_expr.explode());\n        },\n        floor() {\n            return (0, exports._Expr)(_expr.floor());\n        },\n        forwardFill() {\n            return (0, exports._Expr)(_expr.forwardFill());\n        },\n        gather(indices) {\n            if (Array.isArray(indices)) {\n                indices = polars_internal_1.default.lit((0, series_1.Series)(indices).inner());\n            }\n            else {\n                indices = indices.inner();\n            }\n            return wrap(\"gather\", indices);\n        },\n        gatherEvery(n, offset = 0) {\n            return (0, exports._Expr)(_expr.gatherEvery(n, offset));\n        },\n        hash(obj = 0, k1 = 1, k2 = 2, k3 = 3) {\n            if (typeof obj === \"number\" || typeof obj === \"bigint\") {\n                return wrap(\"hash\", BigInt(obj), BigInt(k1), BigInt(k2), BigInt(k3));\n            }\n            const o = { k0: obj, k1: k1, k2: k2, k3: k3, ...obj };\n            return wrap(\"hash\", BigInt(o.k0), BigInt(o.k1), BigInt(o.k2), BigInt(o.k3));\n        },\n        head(length) {\n            if (typeof length === \"number\") {\n                return wrap(\"head\", length);\n            }\n            return wrap(\"head\", length.length);\n        },\n        interpolate(method = \"linear\") {\n            return (0, exports._Expr)(_expr.interpolate(method));\n        },\n        isDuplicated() {\n            return (0, exports._Expr)(_expr.isDuplicated());\n        },\n        isFinite() {\n            return (0, exports._Expr)(_expr.isFinite());\n        },\n        isInfinite() {\n            return (0, exports._Expr)(_expr.isInfinite());\n        },\n        isFirstDistinct() {\n            return (0, exports._Expr)(_expr.isFirstDistinct());\n        },\n        isNan() {\n            return (0, exports._Expr)(_expr.isNan());\n        },\n        isNotNan() {\n            return (0, exports._Expr)(_expr.isNotNan());\n        },\n        isNotNull() {\n            return (0, exports._Expr)(_expr.isNotNull());\n        },\n        isNull() {\n            return (0, exports._Expr)(_expr.isNull());\n        },\n        isUnique() {\n            return (0, exports._Expr)(_expr.isUnique());\n        },\n        isIn(other) {\n            if (Array.isArray(other)) {\n                other = polars_internal_1.default.lit((0, series_1.Series)(other).inner());\n            }\n            else {\n                other = (0, exports.exprToLitOrExpr)(other, false).inner();\n            }\n            return wrap(\"isIn\", other);\n        },\n        keepName() {\n            return (0, exports._Expr)(_expr.keepName());\n        },\n        kurtosis(obj, bias = true) {\n            const fisher = obj?.[\"fisher\"] ?? (typeof obj === \"boolean\" ? obj : true);\n            bias = obj?.[\"bias\"] ?? bias;\n            return (0, exports._Expr)(_expr.kurtosis(fisher, bias));\n        },\n        last() {\n            return (0, exports._Expr)(_expr.last());\n        },\n        list() {\n            return (0, exports._Expr)(_expr.list());\n        },\n        log1p() {\n            console.log(_expr.log1p);\n            return (0, exports._Expr)(_expr.log1p());\n        },\n        log(base) {\n            return (0, exports._Expr)(_expr.log(base ?? Math.E));\n        },\n        lowerBound() {\n            return (0, exports._Expr)(_expr.lowerBound());\n        },\n        peakMax() {\n            return (0, exports._Expr)(_expr.peakMax());\n        },\n        peakMin() {\n            return (0, exports._Expr)(_expr.peakMin());\n        },\n        max() {\n            return (0, exports._Expr)(_expr.max());\n        },\n        mean() {\n            return (0, exports._Expr)(_expr.mean());\n        },\n        median() {\n            return (0, exports._Expr)(_expr.median());\n        },\n        min() {\n            return (0, exports._Expr)(_expr.min());\n        },\n        mode() {\n            return (0, exports._Expr)(_expr.mode());\n        },\n        not() {\n            return (0, exports._Expr)(_expr.not());\n        },\n        nUnique() {\n            return (0, exports._Expr)(_expr.nUnique());\n        },\n        or(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other).inner();\n            return (0, exports._Expr)(_expr.or(expr));\n        },\n        over(...exprs) {\n            const partitionBy = (0, utils_1.selectionToExprList)(exprs, false);\n            return wrap(\"over\", partitionBy);\n        },\n        pow(exponent) {\n            return (0, exports._Expr)(_expr.pow(exponent?.exponent ?? exponent));\n        },\n        prefix(prefix) {\n            return (0, exports._Expr)(_expr.prefix(prefix));\n        },\n        quantile(quantile, interpolation = \"nearest\") {\n            if (exports.Expr.isExpr(quantile)) {\n                quantile = quantile._expr;\n            }\n            else {\n                quantile = polars_internal_1.default.lit(quantile);\n            }\n            return (0, exports._Expr)(_expr.quantile(quantile, interpolation));\n        },\n        rank(method = \"average\", reverse = false) {\n            return (0, exports._Expr)(_expr.rank(method?.method ?? method, method?.reverse ?? reverse));\n        },\n        reinterpret(signed = true) {\n            signed = signed?.signed ?? signed;\n            return (0, exports._Expr)(_expr.reinterpret(signed));\n        },\n        repeatBy(expr) {\n            const e = (0, exports.exprToLitOrExpr)(expr, false)._expr;\n            return (0, exports._Expr)(_expr.repeatBy(e));\n        },\n        replace(old, newValue) {\n            let oldIn = old;\n            let newIn = newValue;\n            if (old && typeof old === \"object\" && !Array.isArray(old)) {\n                oldIn = Object.keys(old[\"old\"]);\n                newIn = Object.values(old[\"old\"]);\n            }\n            return (0, exports._Expr)(_expr.replace((0, exports.exprToLitOrExpr)(oldIn)._expr, (0, exports.exprToLitOrExpr)(newIn)._expr));\n        },\n        replaceStrict(old, newValue, defaultValue, returnDtype) {\n            let oldIn = old;\n            let newIn = newValue;\n            let defIn = defaultValue;\n            if (old && typeof old === \"object\" && !Array.isArray(old)) {\n                oldIn = Object.keys(old[\"old\"]);\n                newIn = Object.values(old[\"old\"]);\n                defIn = old[\"default_\"];\n            }\n            return (0, exports._Expr)(_expr.replaceStrict((0, exports.exprToLitOrExpr)(oldIn)._expr, (0, exports.exprToLitOrExpr)(newIn)._expr, defIn ? (0, exports.exprToLitOrExpr)(defIn)._expr : undefined, returnDtype));\n        },\n        reverse() {\n            return (0, exports._Expr)(_expr.reverse());\n        },\n        rollingMax: rolling(\"rollingMax\"),\n        rollingMean: rolling(\"rollingMean\"),\n        rollingMin: rolling(\"rollingMin\"),\n        rollingSum: rolling(\"rollingSum\"),\n        rollingStd: rolling(\"rollingStd\"),\n        rollingVar: rolling(\"rollingVar\"),\n        rollingMedian: rolling(\"rollingMedian\"),\n        rollingQuantile(val, interpolation, windowSize, weights, minPeriods, center, by, closedWindow, warnIfUnsorted) {\n            if (typeof val === \"number\") {\n                return wrap(\"rollingQuantile\", {\n                    windowSize: `${windowSize}i`,\n                    weights,\n                    minPeriods,\n                    center,\n                });\n            }\n            windowSize =\n                val?.[\"windowSize\"] ?? (typeof val === \"number\" ? val : null);\n            if (windowSize === null) {\n                throw new Error(\"window size is required\");\n            }\n            return wrap(\"rollingQuantile\", val.quantile, val.interpolation ?? \"nearest\", windowSize, val?.[\"weights\"] ?? weights ?? null, val?.[\"minPeriods\"] ?? minPeriods ?? windowSize, val?.[\"center\"] ?? center ?? false, val?.[\"by\"] ?? by, closedWindow, val?.[\"warnIfUnsorted\"] ?? warnIfUnsorted ?? true);\n        },\n        rollingSkew(val, bias = true) {\n            if (typeof val === \"number\") {\n                return wrap(\"rollingSkew\", val, bias);\n            }\n            return wrap(\"rollingSkew\", val.windowSize, val.bias ?? bias);\n        },\n        round(decimals) {\n            return (0, exports._Expr)(_expr.round(decimals?.decimals ?? decimals));\n        },\n        sample(opts, frac, withReplacement = false, seed) {\n            if (opts?.n !== undefined || opts?.frac !== undefined) {\n                return this.sample(opts.n, opts.frac, opts.withReplacement, seed);\n            }\n            if (typeof opts === \"number\") {\n                throw new Error(\"sample_n is not yet supported for expr\");\n            }\n            if (typeof frac === \"number\") {\n                return wrap(\"sampleFrac\", frac, withReplacement, false, seed);\n            }\n            throw new TypeError(\"must specify either 'frac' or 'n'\");\n        },\n        shift(periods) {\n            return (0, exports._Expr)(_expr.shift((0, exports.exprToLitOrExpr)(periods)._expr));\n        },\n        shiftAndFill(optOrPeriods, fillValue) {\n            if (typeof optOrPeriods === \"number\") {\n                return wrap(\"shiftAndFill\", optOrPeriods, fillValue);\n            }\n            return wrap(\"shiftAndFill\", optOrPeriods.periods, optOrPeriods.fillValue);\n        },\n        skew(bias) {\n            return wrap(\"skew\", bias?.bias ?? bias ?? true);\n        },\n        sin() {\n            return (0, exports._Expr)(_expr.sin());\n        },\n        sinh() {\n            return (0, exports._Expr)(_expr.sinh());\n        },\n        slice(arg, len) {\n            if (typeof arg === \"number\") {\n                return wrap(\"slice\", polars_internal_1.default.lit(arg), polars_internal_1.default.lit(len));\n            }\n            return wrap(\"slice\", polars_internal_1.default.lit(arg.offset), polars_internal_1.default.lit(arg.length));\n        },\n        sort(reverse = false, nullsLast = false, maintain_order = false) {\n            if (typeof reverse === \"boolean\") {\n                return wrap(\"sortWith\", reverse, nullsLast, false, maintain_order);\n            }\n            return wrap(\"sortWith\", reverse?.reverse ?? false, reverse?.nullsLast ?? nullsLast, false, reverse?.maintain_order ?? maintain_order);\n        },\n        sortBy(arg, reverse = false) {\n            if (arg?.by !== undefined) {\n                return this.sortBy(arg.by, arg.reverse);\n            }\n            reverse = Array.isArray(reverse) ? reverse.flat() : [reverse];\n            const by = (0, utils_1.selectionToExprList)(arg, false);\n            return wrap(\"sortBy\", by, reverse);\n        },\n        std() {\n            return (0, exports._Expr)(_expr.std());\n        },\n        suffix(suffix) {\n            return (0, exports._Expr)(_expr.suffix(suffix));\n        },\n        sum() {\n            return (0, exports._Expr)(_expr.sum());\n        },\n        tail(length) {\n            return (0, exports._Expr)(_expr.tail(length));\n        },\n        tan() {\n            return (0, exports._Expr)(_expr.tan());\n        },\n        tanh() {\n            return (0, exports._Expr)(_expr.tanh());\n        },\n        unique(opt) {\n            if (opt || opt?.maintainOrder) {\n                return wrap(\"uniqueStable\");\n            }\n            return wrap(\"unique\");\n        },\n        upperBound() {\n            return (0, exports._Expr)(_expr.upperBound());\n        },\n        where(expr) {\n            return this.filter(expr);\n        },\n        var() {\n            return (0, exports._Expr)(_expr.var());\n        },\n        add: wrapExprArg(\"add\"),\n        sub: wrapExprArg(\"sub\"),\n        div: wrapExprArg(\"div\"),\n        mul: wrapExprArg(\"mul\"),\n        rem: wrapExprArg(\"rem\"),\n        plus: wrapExprArg(\"add\"),\n        minus: wrapExprArg(\"sub\"),\n        divideBy: wrapExprArg(\"div\"),\n        multiplyBy: wrapExprArg(\"mul\"),\n        modulo: wrapExprArg(\"rem\"),\n        eq: wrapExprArg(\"eq\"),\n        equals: wrapExprArg(\"eq\"),\n        gtEq: wrapExprArg(\"gtEq\"),\n        greaterThanEquals: wrapExprArg(\"gtEq\"),\n        gt: wrapExprArg(\"gt\"),\n        greaterThan: wrapExprArg(\"gt\"),\n        ltEq: wrapExprArg(\"ltEq\"),\n        lessThanEquals: wrapExprArg(\"ltEq\"),\n        lt: wrapExprArg(\"lt\"),\n        lessThan: wrapExprArg(\"lt\"),\n        neq: wrapExprArg(\"neq\"),\n        notEquals: wrapExprArg(\"neq\"),\n    };\n}",
    "DataFrame": "function DataFrameConstructor(data, options) {\n    if (!data) {\n        return (0, exports._DataFrame)(objToDF({}));\n    }\n    if (Array.isArray(data)) {\n        return (0, exports._DataFrame)((0, construction_1.arrayToJsDataFrame)(data, options));\n    }\n    return (0, exports._DataFrame)(objToDF(data, options));\n}",
    "LazyDataFrame": "(_ldf) => {\n    const unwrap = (method, ...args) => {\n        return _ldf[method](...args);\n    };\n    const wrap = (method, ...args) => {\n        return (0, exports._LazyDataFrame)(unwrap(method, ...args));\n    };\n    return {\n        _ldf,\n        [inspect]() {\n            return _ldf.describeOptimizedPlan();\n        },\n        get [Symbol.toStringTag]() {\n            return \"LazyDataFrame\";\n        },\n        get columns() {\n            return _ldf.columns;\n        },\n        describePlan() {\n            return _ldf.describePlan();\n        },\n        describeOptimizedPlan() {\n            return _ldf.describeOptimizedPlan();\n        },\n        cache() {\n            return (0, exports._LazyDataFrame)(_ldf.cache());\n        },\n        clone() {\n            return (0, exports._LazyDataFrame)(_ldf.clone());\n        },\n        collectSync() {\n            return (0, dataframe_1._DataFrame)(_ldf.collectSync());\n        },\n        collect(opts) {\n            if (opts?.noOptimization) {\n                opts.predicatePushdown = false;\n                opts.projectionPushdown = false;\n                opts.slicePushdown = false;\n                opts.commSubplanElim = false;\n                opts.commSubexprElim = false;\n            }\n            if (opts?.streaming)\n                opts.commSubplanElim = false;\n            if (opts) {\n                _ldf = _ldf.optimizationToggle(opts.typeCoercion, opts.predicatePushdown, opts.projectionPushdown, opts.simplifyExpression, opts.slicePushdown, opts.commSubplanElim, opts.commSubexprElim, opts.streaming);\n            }\n            return _ldf.collect().then(dataframe_1._DataFrame);\n        },\n        drop(...cols) {\n            return (0, exports._LazyDataFrame)(_ldf.dropColumns(cols.flat(2)));\n        },\n        distinct(...args) {\n            return (0, exports._LazyDataFrame)(_ldf.unique(...args));\n        },\n        unique(opts = false, subset, keep = \"first\") {\n            const defaultOptions = {\n                maintainOrder: false,\n                keep: \"first\",\n            };\n            if (typeof opts === \"boolean\") {\n                const o = { ...defaultOptions, maintainOrder: opts, subset, keep };\n                return (0, exports._LazyDataFrame)(_ldf.unique(o.maintainOrder, o?.subset?.flat(2), o.keep));\n            }\n            if (opts.subset) {\n                opts.subset = [opts.subset].flat(3);\n            }\n            const o = { ...defaultOptions, ...opts };\n            return (0, exports._LazyDataFrame)(_ldf.unique(o.maintainOrder, o.subset, o.keep));\n        },\n        dropNulls(...subset) {\n            if (subset.length) {\n                return wrap(\"dropNulls\", subset.flat(2));\n            }\n            return wrap(\"dropNulls\");\n        },\n        explode(...columns) {\n            if (!columns.length) {\n                const cols = (0, utils_1.selectionToExprList)(_ldf.columns, false);\n                return wrap(\"explode\", cols);\n            }\n            const column = (0, utils_1.selectionToExprList)(columns, false);\n            return wrap(\"explode\", column);\n        },\n        fetchSync(numRows, opts) {\n            if (opts?.noOptimization) {\n                opts.predicatePushdown = false;\n                opts.projectionPushdown = false;\n                opts.slicePushdown = false;\n                opts.commSubplanElim = false;\n                opts.commSubexprElim = false;\n            }\n            if (opts?.streaming)\n                opts.commSubplanElim = false;\n            if (opts) {\n                _ldf = _ldf.optimizationToggle(opts.typeCoercion, opts.predicatePushdown, opts.projectionPushdown, opts.simplifyExpr, opts.slicePushdown, opts.commSubplanElim, opts.commSubexprElim, opts.streaming);\n            }\n            return (0, dataframe_1._DataFrame)(_ldf.fetchSync(numRows));\n        },\n        fetch(numRows, opts) {\n            if (opts?.noOptimization) {\n                opts.predicatePushdown = false;\n                opts.projectionPushdown = false;\n                opts.slicePushdown = false;\n                opts.commSubplanElim = false;\n                opts.commSubexprElim = false;\n            }\n            if (opts?.streaming)\n                opts.commSubplanElim = false;\n            if (opts) {\n                _ldf = _ldf.optimizationToggle(opts.typeCoercion, opts.predicatePushdown, opts.projectionPushdown, opts.simplifyExpr, opts.slicePushdown, opts.commSubplanElim, opts.commSubexprElim, opts.streaming);\n            }\n            return _ldf.fetch(numRows).then(dataframe_1._DataFrame);\n        },\n        first() {\n            return this.fetchSync(1);\n        },\n        fillNull(exprOrValue) {\n            const fillValue = (0, expr_1.exprToLitOrExpr)(exprOrValue)._expr;\n            return (0, exports._LazyDataFrame)(_ldf.fillNull(fillValue));\n        },\n        filter(exprOrValue) {\n            const predicate = (0, expr_1.exprToLitOrExpr)(exprOrValue, false)._expr;\n            return (0, exports._LazyDataFrame)(_ldf.filter(predicate));\n        },\n        groupBy(opt, maintainOrder = true) {\n            if (opt?.by !== undefined) {\n                const by = (0, utils_1.selectionToExprList)([opt.by], false);\n                return (0, groupby_1._LazyGroupBy)(_ldf.groupby(by, opt.maintainOrder));\n            }\n            const by = (0, utils_1.selectionToExprList)([opt], false);\n            return (0, groupby_1._LazyGroupBy)(_ldf.groupby(by, maintainOrder));\n        },\n        groupByRolling({ indexColumn, by, period, offset, closed, check_sorted }) {\n            offset = offset ?? `-${period}`;\n            closed = closed ?? \"right\";\n            by = prepareGroupbyInputs(by);\n            check_sorted = check_sorted ?? false;\n            const lgb = _ldf.groupbyRolling(polars_internal_1.default.col(indexColumn), period, offset, closed, by, check_sorted);\n            return (0, groupby_1._LazyGroupBy)(lgb);\n        },\n        groupByDynamic({ indexColumn, every, period, offset, includeBoundaries, closed, by, start_by, check_sorted, }) {\n            period = period ?? every;\n            offset = offset ?? `-${period}`;\n            closed = closed ?? \"right\";\n            by = prepareGroupbyInputs(by);\n            includeBoundaries = includeBoundaries ?? false;\n            start_by = start_by ?? \"monday\";\n            check_sorted = check_sorted ?? false;\n            const lgb = _ldf.groupbyDynamic(polars_internal_1.default.col(indexColumn), every, period, offset, includeBoundaries, closed, by, start_by, check_sorted);\n            return (0, groupby_1._LazyGroupBy)(lgb);\n        },\n        head(len = 5) {\n            return (0, exports._LazyDataFrame)(_ldf.slice(0, len));\n        },\n        inner() {\n            return _ldf;\n        },\n        join(df, options) {\n            options = {\n                how: \"inner\",\n                suffix: \"right\",\n                allowParallel: true,\n                forceParallel: false,\n                ...options,\n            };\n            const { how, suffix, allowParallel, forceParallel } = options;\n            if (how === \"cross\") {\n                return (0, exports._LazyDataFrame)(_ldf.join(df._ldf, [], [], allowParallel, forceParallel, how, suffix, [], []));\n            }\n            let leftOn;\n            let rightOn;\n            if (options.on) {\n                const on = (0, utils_1.selectionToExprList)(options.on, false);\n                leftOn = on;\n                rightOn = on;\n            }\n            else if ((options.leftOn && !options.rightOn) ||\n                (options.rightOn && !options.leftOn)) {\n                throw new TypeError(\"You should pass the column to join on as an argument.\");\n            }\n            else {\n                leftOn = (0, utils_1.selectionToExprList)(options.leftOn, false);\n                rightOn = (0, utils_1.selectionToExprList)(options.rightOn, false);\n            }\n            const ldf = _ldf.join(df._ldf, leftOn, rightOn, allowParallel, forceParallel, how, suffix, [], []);\n            return (0, exports._LazyDataFrame)(ldf);\n        },\n        joinAsof(other, options) {\n            options = {\n                suffix: \"_right\",\n                allowParallel: true,\n                forceParallel: false,\n                strategy: \"backward\",\n                ...options,\n            };\n            const { suffix, strategy, allowParallel, forceParallel } = options;\n            let leftOn;\n            let rightOn;\n            if (!other?._ldf) {\n                throw new TypeError(\"Expected a 'lazyFrame' as join table\");\n            }\n            if (options.on) {\n                leftOn = rightOn = options.on;\n            }\n            else if ((options.leftOn && !options.rightOn) ||\n                (options.rightOn && !options.leftOn)) {\n                throw new TypeError(\"You should pass the column to join on as an argument.\");\n            }\n            else {\n                leftOn = options.leftOn;\n                rightOn = options.rightOn;\n            }\n            let byLeft;\n            if (typeof options.byLeft === \"string\") {\n                byLeft = [options.byLeft];\n            }\n            else if (Array.isArray(options.byLeft)) {\n                byLeft = options.byLeft;\n            }\n            let byRight;\n            if (typeof options.byRight === \"string\") {\n                byRight = [options.byRight];\n            }\n            else if (Array.isArray(options.byRight)) {\n                byRight = options.byRight;\n            }\n            if (typeof options.by === \"string\") {\n                byLeft = byRight = [options.by];\n            }\n            else if (Array.isArray(options.by)) {\n                byLeft = byRight = options.by;\n            }\n            let toleranceStr;\n            let toleranceNum;\n            if (typeof options.tolerance === \"string\") {\n                toleranceStr = options.tolerance;\n            }\n            else {\n                toleranceNum = options.tolerance;\n            }\n            const ldf = _ldf.joinAsof(other._ldf, polars_internal_1.default.col(leftOn), polars_internal_1.default.col(rightOn), byLeft, byRight, allowParallel, forceParallel, suffix, strategy, toleranceNum, toleranceStr);\n            return (0, exports._LazyDataFrame)(ldf);\n        },\n        last() {\n            return (0, exports._LazyDataFrame)(_ldf.tail(1));\n        },\n        limit(len = 5) {\n            return (0, exports._LazyDataFrame)(_ldf.slice(0, len));\n        },\n        max() {\n            return (0, exports._LazyDataFrame)(_ldf.max());\n        },\n        mean() {\n            return (0, exports._LazyDataFrame)(_ldf.mean());\n        },\n        median() {\n            return (0, exports._LazyDataFrame)(_ldf.median());\n        },\n        melt(ids, values) {\n            return (0, exports._LazyDataFrame)(_ldf.unpivot((0, utils_1.columnOrColumnsStrict)(ids), (0, utils_1.columnOrColumnsStrict)(values)));\n        },\n        unpivot(ids, values) {\n            return (0, exports._LazyDataFrame)(_ldf.unpivot((0, utils_1.columnOrColumnsStrict)(ids), (0, utils_1.columnOrColumnsStrict)(values)));\n        },\n        min() {\n            return (0, exports._LazyDataFrame)(_ldf.min());\n        },\n        quantile(quantile, interpolation = \"nearest\") {\n            return (0, exports._LazyDataFrame)(_ldf.quantile(quantile, interpolation));\n        },\n        rename(mapping) {\n            const existing = Object.keys(mapping);\n            const replacements = Object.values(mapping);\n            return (0, exports._LazyDataFrame)(_ldf.rename(existing, replacements));\n        },\n        reverse() {\n            return (0, exports._LazyDataFrame)(_ldf.reverse());\n        },\n        select(...exprs) {\n            const selections = (0, utils_1.selectionToExprList)(exprs, false);\n            return (0, exports._LazyDataFrame)(_ldf.select(selections));\n        },\n        shift(periods) {\n            return (0, exports._LazyDataFrame)(_ldf.shift(periods));\n        },\n        shiftAndFill(opts, fillValue) {\n            if (typeof opts === \"number\") {\n                return (0, exports._LazyDataFrame)(_ldf.shiftAndFill(opts, fillValue));\n            }\n            return (0, exports._LazyDataFrame)(_ldf.shiftAndFill(opts?.n, opts?.fillValue));\n        },\n        slice(opt, len) {\n            if (opt?.offset !== undefined) {\n                return (0, exports._LazyDataFrame)(_ldf.slice(opt.offset, opt.length));\n            }\n            return (0, exports._LazyDataFrame)(_ldf.slice(opt, len));\n        },\n        sort(arg, descending = false, nulls_last = false, maintain_order = false) {\n            if (arg?.by !== undefined) {\n                return this.sort(arg.by, arg.descending, arg.nulls_last, arg.maintain_order);\n            }\n            if (typeof arg === \"string\") {\n                return wrap(\"sort\", arg, descending, nulls_last, maintain_order);\n            }\n            const by = (0, utils_1.selectionToExprList)(arg, false);\n            return wrap(\"sortByExprs\", by, descending, nulls_last, maintain_order);\n        },\n        std() {\n            return (0, exports._LazyDataFrame)(_ldf.std());\n        },\n        sum() {\n            return (0, exports._LazyDataFrame)(_ldf.sum());\n        },\n        var() {\n            return (0, exports._LazyDataFrame)(_ldf.var());\n        },\n        tail(length = 5) {\n            return (0, exports._LazyDataFrame)(_ldf.tail(length));\n        },\n        toJSON(...args) {\n            // this is passed by `JSON.stringify` when calling `toJSON()`\n            if (args[0] === \"\") {\n                return JSON.parse(_ldf.serialize(\"json\").toString());\n            }\n            return _ldf.serialize(\"json\").toString();\n        },\n        serialize(format) {\n            return _ldf.serialize(format);\n        },\n        withColumn(expr) {\n            return (0, exports._LazyDataFrame)(_ldf.withColumn(expr._expr));\n        },\n        withColumns(...columns) {\n            const exprs = (0, utils_1.selectionToExprList)(columns, false);\n            return (0, exports._LazyDataFrame)(_ldf.withColumns(exprs));\n        },\n        withColumnRenamed(existing, replacement) {\n            return (0, exports._LazyDataFrame)(_ldf.rename([existing], [replacement]));\n        },\n        withRowCount(name = \"row_nr\") {\n            return (0, exports._LazyDataFrame)(_ldf.withRowCount(name));\n        },\n        sinkCSV(path, options = {}) {\n            options.maintainOrder = options.maintainOrder ?? false;\n            _ldf.sinkCsv(path, options);\n        },\n        sinkParquet(path, options = {}) {\n            options.compression = options.compression ?? \"zstd\";\n            options.statistics = options.statistics ?? false;\n            _ldf.sinkParquet(path, options);\n        },\n    };\n}",
    "Series": "(arg0, arg1, dtype, strict) => {\n    if (typeof arg0 === \"string\") {\n        const _s = (0, construction_1.arrayToJsSeries)(arg0, arg1, dtype, strict);\n        return _Series(_s);\n    }\n    return SeriesConstructor(\"\", arg0);\n}",
    "Config": {
      "setUtf8Tables": "setUtf8Tables() {\n        process.env[\"POLARS_FMT_NO_UTF8\"] = undefined;\n        return this;\n    }",
      "setAsciiTables": "setAsciiTables() {\n        process.env[\"POLARS_FMT_NO_UTF8\"] = \"1\";\n        return this;\n    }",
      "setTblWidthChars": "setTblWidthChars(width) {\n        process.env[\"POLARS_TABLE_WIDTH\"] = String(width);\n        return this;\n    }",
      "setTblRows": "setTblRows(n) {\n        process.env[\"POLARS_FMT_MAX_ROWS\"] = String(n);\n        return this;\n    }",
      "setTblCols": "setTblCols(n) {\n        process.env[\"POLARS_FMT_MAX_COLS\"] = String(n);\n        return this;\n    }",
      "setGlobalStringCache": "setGlobalStringCache() {\n        native_polars_1.default.toggleStringCache(true);\n        return this;\n    }",
      "unsetGlobalStringCache": "unsetGlobalStringCache() {\n        native_polars_1.default.toggleStringCache(false);\n        return this;\n    }"
    },
    "Field": "class Field {\n    name;\n    dtype;\n    constructor(name, dtype) {\n        this.name = name;\n        this.dtype = dtype;\n    }\n    toString() {\n        return `Field(\"${this.name}\", ${this.dtype})`;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            dtype: this.dtype,\n        };\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.toJSON();\n    }\n}",
    "repeat": "function repeat(value, n, name = \"\") {\n    const dtype = (0, construction_1.jsTypeToPolarsType)(value);\n    const s = polars_internal_1.default.JsSeries.repeat(name, value, n, dtype);\n    return (0, series_1._Series)(s);\n}",
    "concat": "function concat(items, options = { rechunk: true, how: \"vertical\" }) {\n    const { rechunk, how } = options;\n    if (!items.length) {\n        throw new RangeError(\"cannot concat empty list\");\n    }\n    if ((0, utils_1.isDataFrameArray)(items)) {\n        let df;\n        switch (how) {\n            case \"vertical\":\n                df = items.reduce((acc, curr) => acc.vstack(curr));\n                break;\n            case \"horizontal\":\n                df = (0, dataframe_1._DataFrame)(polars_internal_1.default.horizontalConcat(items.map((i) => i.inner())));\n                break;\n            case \"diagonal\":\n                df = (0, dataframe_1._DataFrame)(polars_internal_1.default.diagonalConcat(items.map((i) => i.inner())));\n                break;\n            default:\n                throw new TypeError(\"unknown concat how option\");\n        }\n        return rechunk ? df.rechunk() : df;\n    }\n    if ((0, utils_1.isLazyDataFrameArray)(items)) {\n        const df = (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.concatLf(items.map((i) => i.inner()), how, rechunk));\n        return df;\n    }\n    if ((0, utils_1.isSeriesArray)(items)) {\n        const s = items.reduce((acc, curr) => acc.concat(curr));\n        return rechunk ? s.rechunk() : s;\n    }\n    throw new TypeError(\"can only concat series and dataframes\");\n}",
    "scanCSV": "function scanCSV(path, options) {\n    options = { ...scanCsvDefaultOptions, ...options };\n    return (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.scanCsv(path, options));\n}",
    "scanJson": "function scanJson(path, options) {\n    options = { ...readJsonDefaultOptions, ...options };\n    return (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.scanJson(path, options));\n}",
    "scanIPC": "function scanIPC(path, options = {}) {\n    return (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.scanIpc(path, options));\n}",
    "scanParquet": "function scanParquet(source, options = {}) {\n    const defaultOptions = { parallel: \"auto\" };\n    const pliOptions = { ...defaultOptions, ...options };\n    return (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.scanParquet(source, pliOptions));\n}",
    "readRecords": "function readRecords(records, options) {\n    if (options?.schema) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.fromRows(records, options.schema));\n    }\n    return (0, dataframe_1._DataFrame)(polars_internal_1.default.fromRows(records, undefined, options?.inferSchemaLength));\n}",
    "readCSV": "function readCSV(pathOrBody, options) {\n    options = { ...readCsvDefaultOptions, ...options };\n    const extensions = [\".tsv\", \".csv\"];\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readCsv(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, extensions);\n        if (inline) {\n            const buf = Buffer.from(pathOrBody, \"utf-8\");\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readCsv(buf, options));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readCsv(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
    "readIPC": "function readIPC(pathOrBody, options = {}) {\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpc(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, [\".ipc\"]);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpc(Buffer.from(pathOrBody, \"utf-8\"), options));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpc(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
    "readIPCStream": "function readIPCStream(pathOrBody, options = {}) {\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpcStream(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, [\".ipc\"]);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpcStream(Buffer.from(pathOrBody, \"utf-8\"), options));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpcStream(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
    "readJSON": "function readJSON(pathOrBody, options = readJsonDefaultOptions) {\n    options = { ...readJsonDefaultOptions, ...options };\n    const method = options.format === \"lines\" ? polars_internal_1.default.readJsonLines : polars_internal_1.default.readJson;\n    const extensions = [\".ndjson\", \".json\", \".jsonl\"];\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readJson(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, extensions);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(method(Buffer.from(pathOrBody, \"utf-8\"), options));\n        }\n        return (0, dataframe_1._DataFrame)(method(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
    "readParquet": "function readParquet(pathOrBody, options) {\n    const pliOptions = {};\n    if (typeof options?.columns?.[0] === \"number\") {\n        pliOptions.projection = options?.columns;\n    }\n    else {\n        pliOptions.columns = options?.columns;\n    }\n    pliOptions.nRows = options?.numRows;\n    pliOptions.rowCount = options?.rowCount;\n    const parallel = options?.parallel ?? \"auto\";\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readParquet(pathOrBody, pliOptions, parallel));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, [\".parquet\"]);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readParquet(Buffer.from(pathOrBody), pliOptions, parallel));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readParquet(pathOrBody, pliOptions, parallel));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
    "readAvro": "function readAvro(pathOrBody, options = {}) {\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readAvro(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, [\".avro\"]);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readAvro(Buffer.from(pathOrBody), options));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readAvro(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
    "readCSVStream": "function readCSVStream(stream, options) {\n    const batchSize = options?.batchSize ?? 10000;\n    let count = 0;\n    const end = options?.endRows ?? Number.POSITIVE_INFINITY;\n    return new Promise((resolve, reject) => {\n        const s = stream.pipe(new LineBatcher({ batchSize }));\n        const chunks = [];\n        s.on(\"data\", (chunk) => {\n            // early abort if 'end rows' is specified\n            if (count <= end) {\n                chunks.push(chunk);\n            }\n            else {\n                s.end();\n            }\n            count += batchSize;\n        }).on(\"end\", () => {\n            try {\n                const buff = Buffer.concat(chunks);\n                const df = readCSVBuffer(buff, options);\n                resolve(df);\n            }\n            catch (err) {\n                reject(err);\n            }\n        });\n    });\n}",
    "readJSONStream": "function readJSONStream(stream, options = readJsonDefaultOptions) {\n    options = { ...readJsonDefaultOptions, ...options };\n    return new Promise((resolve, reject) => {\n        const chunks = [];\n        stream\n            .pipe(new LineBatcher({ batchSize: options.batchSize }))\n            .on(\"data\", (chunk) => {\n            try {\n                const df = (0, dataframe_1._DataFrame)(polars_internal_1.default.readJson(chunk, options));\n                chunks.push(df);\n            }\n            catch (err) {\n                reject(err);\n            }\n        })\n            .on(\"end\", () => {\n            try {\n                const df = (0, functions_1.concat)(chunks);\n                resolve(df);\n            }\n            catch (err) {\n                reject(err);\n            }\n        });\n    });\n}",
    "col": "function col(col) {\n    if (series_1.Series.isSeries(col)) {\n        col = col.toArray();\n    }\n    if (Array.isArray(col)) {\n        return (0, expr_1._Expr)(polars_internal_1.default.cols(col));\n    }\n    if (typeof col === \"object\" && Object.values(col)[0] === \"DataType\") {\n        return (0, expr_1._Expr)(polars_internal_1.default.dtypeCols([col]));\n    }\n    return (0, expr_1._Expr)(polars_internal_1.default.col(col));\n}",
    "nth": "function nth(n) {\n    return (0, expr_1._Expr)(polars_internal_1.default.nth(n));\n}",
    "cols": "function cols(...cols) {\n    return col(cols.flat());\n}",
    "lit": "function lit(value) {\n    if (Array.isArray(value)) {\n        value = (0, series_1.Series)(value);\n    }\n    if (series_1.Series.isSeries(value)) {\n        return (0, expr_1._Expr)(polars_internal_1.default.lit(value.inner()));\n    }\n    return (0, expr_1._Expr)(polars_internal_1.default.lit(value));\n}",
    "intRange": "function intRange(opts, end, step = 1, dtype = datatypes_1.DataType.Int64, eager) {\n    // @deprecated since 0.15.0\n    if (typeof opts?.low === \"number\") {\n        return intRange(opts.low, opts.high, opts.step, opts.dtype, opts.eager);\n    }\n    if (typeof opts?.start === \"number\") {\n        return intRange(opts.start, opts.end, opts.step, opts.dtype, opts.eager);\n    }\n    // if expression like pl.len() passed\n    if (end === undefined || end === null) {\n        end = opts;\n        opts = 0;\n    }\n    const start = (0, expr_1.exprToLitOrExpr)(opts, false);\n    end = (0, expr_1.exprToLitOrExpr)(end, false);\n    if (eager) {\n        const df = (0, dataframe_1.DataFrame)({ a: [1] });\n        return df\n            .select(intRange(start, end, step).alias(\"intRange\"))\n            .getColumn(\"intRange\");\n    }\n    return (0, expr_1._Expr)(polars_internal_1.default.intRange(start, end, step, dtype));\n}",
    "intRanges": "function intRanges(start, end, step = 1, dtype = datatypes_1.DataType.Int64, eager) {\n    start = (0, expr_1.exprToLitOrExpr)(start, false);\n    end = (0, expr_1.exprToLitOrExpr)(end, false);\n    step = (0, expr_1.exprToLitOrExpr)(step, false);\n    if (eager) {\n        const df = (0, dataframe_1.DataFrame)({ a: [1] });\n        return df\n            .select(intRanges(start, end, step, dtype).alias(\"intRanges\"))\n            .getColumn(\"intRanges\");\n    }\n    return (0, expr_1._Expr)(polars_internal_1.default.intRanges(start, end, step, dtype));\n}",
    "argSortBy": "function argSortBy(exprs, descending = false) {\n    if (!Array.isArray(descending)) {\n        descending = Array.from({ length: exprs.length }, () => descending);\n    }\n    const by = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.argSortBy(by, descending));\n}",
    "avg": "function avg(column) {\n    return mean(column);\n}",
    "concatList": "function concatList(...exprs) {\n    const items = (0, utils_1.selectionToExprList)(exprs, false);\n    return expr_1.Expr(polars_internal_1.default.concatLst(items));\n}",
    "concatString": "function concatString(opts, sep = \",\", ignoreNulls = true) {\n    if (opts?.exprs) {\n        return concatString(opts.exprs, opts.sep, opts.ignoreNulls);\n    }\n    const items = (0, utils_1.selectionToExprList)(opts, false);\n    return expr_1.Expr(polars_internal_1.default.concatStr(items, sep, ignoreNulls));\n}",
    "count": "function count(column) {\n    if (series_1.Series.isSeries(column)) {\n        return column.len();\n    }\n    return col(column).count();\n}",
    "cov": "function cov(a, b, ddof = 1) {\n    a = (0, expr_1.exprToLitOrExpr)(a, false);\n    b = (0, expr_1.exprToLitOrExpr)(b, false);\n    return (0, expr_1._Expr)(polars_internal_1.default.cov(a, b, ddof));\n}",
    "exclude": "function exclude(...columns) {\n    return col(\"*\").exclude(columns);\n}",
    "element": "function element() {\n    return col(\"\");\n}",
    "first": "function first(column) {\n    if (!column) {\n        return (0, expr_1._Expr)(polars_internal_1.default.first());\n    }\n    if (series_1.Series.isSeries(column)) {\n        if (column.length) {\n            return column.get(0);\n        }\n        throw new RangeError(\"The series is empty, so no first value can be returned.\");\n    }\n    return col(column).first();\n}",
    "format": "function format(strings, ...expr) {\n    if (typeof strings === \"string\") {\n        const s = strings.split(\"{}\");\n        if (s.length - 1 !== expr.length) {\n            throw new RangeError(\"number of placeholders should equal the number of arguments\");\n        }\n        return format(s, ...expr);\n    }\n    const d = (0, utils_1.range)(0, Math.max(strings.length, expr.length))\n        .flatMap((i) => {\n        const sVal = strings[i] ? lit(strings[i]) : [];\n        const exprVal = expr[i] ? (0, expr_1.exprToLitOrExpr)(expr[i], false) : [];\n        return [sVal, exprVal];\n    })\n        .flat();\n    return concatString(d, \"\");\n}",
    "groups": "function groups(column) {\n    return col(column).aggGroups();\n}",
    "head": "function head(column, n) {\n    if (series_1.Series.isSeries(column)) {\n        return column.head(n);\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).head(n);\n}",
    "last": "function last(column) {\n    if (series_1.Series.isSeries(column)) {\n        if (column.length) {\n            return column.get(-1);\n        }\n        throw new RangeError(\"The series is empty, so no last value can be returned.\");\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).last();\n}",
    "len": "function len() {\n    return (0, expr_1._Expr)(polars_internal_1.default.len());\n}",
    "mean": "function mean(column) {\n    if (series_1.Series.isSeries(column)) {\n        return column.mean();\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).mean();\n}",
    "median": "function median(column) {\n    if (series_1.Series.isSeries(column)) {\n        return column.median();\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).median();\n}",
    "nUnique": "function nUnique(column) {\n    if (series_1.Series.isSeries(column)) {\n        return column.nUnique();\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).nUnique();\n}",
    "pearsonCorr": "function pearsonCorr(a, b) {\n    a = (0, expr_1.exprToLitOrExpr)(a, false);\n    b = (0, expr_1.exprToLitOrExpr)(b, false);\n    return (0, expr_1._Expr)(polars_internal_1.default.pearsonCorr(a, b));\n}",
    "quantile": "function quantile(column, q) {\n    if (series_1.Series.isSeries(column)) {\n        return column.quantile(q);\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).quantile(q);\n}",
    "select": "function select(expr, ...exprs) {\n    return (0, dataframe_1.DataFrame)({}).select(expr, ...exprs);\n}",
    "struct": "function struct(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    if (series_1.Series.isSeries(exprs[0])) {\n        return select((0, expr_1._Expr)(polars_internal_1.default.asStruct(exprs.map((e) => polars_internal_1.default.lit(e.inner()))))).toSeries();\n    }\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.asStruct(exprs));\n}",
    "allHorizontal": "function allHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.allHorizontal(exprs));\n}",
    "anyHorizontal": "function anyHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.anyHorizontal(exprs));\n}",
    "minHorizontal": "function minHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.minHorizontal(exprs));\n}",
    "maxHorizontal": "function maxHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.maxHorizontal(exprs));\n}",
    "sumHorizontal": "function sumHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.sumHorizontal(exprs));\n}",
    "spearmanRankCorr": "function spearmanRankCorr(a, b) {\n    a = (0, expr_1.exprToLitOrExpr)(a, false);\n    b = (0, expr_1.exprToLitOrExpr)(b, false);\n    return (0, expr_1._Expr)(polars_internal_1.default.spearmanRankCorr(a, b, null, false));\n}",
    "tail": "function tail(column, n) {\n    if (series_1.Series.isSeries(column)) {\n        return column.tail(n);\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).tail(n);\n}",
    "list": "function list(column) {\n    return (0, expr_1.exprToLitOrExpr)(column, false).list();\n}",
    "when": "function when(expr) {\n    return When(polars_internal_1.default.when(expr._expr));\n}",
    "version": "0.16.0",
    "Categorical": {
      "identity": "DataType"
    },
    "Int8": {
      "identity": "DataType"
    },
    "Int16": {
      "identity": "DataType"
    },
    "Int32": {
      "identity": "DataType"
    },
    "Int64": {
      "identity": "DataType"
    },
    "UInt8": {
      "identity": "DataType"
    },
    "UInt16": {
      "identity": "DataType"
    },
    "UInt32": {
      "identity": "DataType"
    },
    "UInt64": {
      "identity": "DataType"
    },
    "Float32": {
      "identity": "DataType"
    },
    "Float64": {
      "identity": "DataType"
    },
    "Bool": {
      "identity": "DataType"
    },
    "Utf8": {
      "identity": "DataType"
    },
    "String": {
      "identity": "DataType"
    },
    "List": "List(inner) {\n        return new List(inner);\n    }",
    "FixedSizeList": "FixedSizeList(inner, listSize) {\n        return new FixedSizeList(inner, listSize);\n    }",
    "Date": {
      "identity": "DataType"
    },
    "Datetime": "Datetime(timeUnit, timeZone = null) {\n        return new Datetime(timeUnit ?? \"ms\", timeZone);\n    }",
    "Time": {
      "identity": "DataType"
    },
    "Object": {
      "identity": "DataType"
    },
    "Null": {
      "identity": "DataType"
    },
    "Struct": "Struct(fields) {\n        return new Struct(fields);\n    }",
    "Decimal": "Decimal(precision, scale) {\n        return new Decimal(precision, scale);\n    }",
    "SQLContext": "function SQLContext(frames) {\n        return new sql.SQLContext(frames);\n    }"
  },
  "Expr": "(_expr) => {\n    const unwrap = (method, ...args) => {\n        return _expr[method](...args);\n    };\n    const wrap = (method, ...args) => {\n        return (0, exports._Expr)(unwrap(method, ...args));\n    };\n    const wrapExprArg = (method, lit = false) => (other) => {\n        const expr = (0, exports.exprToLitOrExpr)(other, lit).inner();\n        return wrap(method, expr);\n    };\n    const rolling = (method) => (opts, weights, minPeriods, center) => {\n        const windowSize = opts?.[\"windowSize\"] ?? (typeof opts === \"number\" ? opts : null);\n        if (windowSize === null) {\n            throw new Error(\"window size is required\");\n        }\n        const callOpts = {\n            windowSize: windowSize,\n            weights: opts?.[\"weights\"] ?? weights,\n            minPeriods: opts?.[\"minPeriods\"] ?? minPeriods ?? windowSize,\n            center: opts?.[\"center\"] ?? center ?? false,\n        };\n        return wrap(method, callOpts);\n    };\n    return {\n        _expr,\n        [Symbol.toStringTag]() {\n            return \"Expr\";\n        },\n        [utils_1.INSPECT_SYMBOL]() {\n            return _expr.toString();\n        },\n        serialize(format) {\n            return _expr.serialize(format);\n        },\n        toString() {\n            return _expr.toString();\n        },\n        toJSON(...args) {\n            // this is passed by `JSON.stringify` when calling `toJSON()`\n            if (args[0] === \"\") {\n                return _expr.toJs();\n            }\n            return _expr.serialize(\"json\").toString();\n        },\n        get str() {\n            return str.ExprStringFunctions(_expr);\n        },\n        get lst() {\n            return lst.ExprListFunctions(_expr);\n        },\n        get date() {\n            return dt.ExprDateTimeFunctions(_expr);\n        },\n        get struct() {\n            return struct.ExprStructFunctions(_expr);\n        },\n        abs() {\n            return (0, exports._Expr)(_expr.abs());\n        },\n        aggGroups() {\n            return (0, exports._Expr)(_expr.aggGroups());\n        },\n        alias(name) {\n            return (0, exports._Expr)(_expr.alias(name));\n        },\n        inner() {\n            return _expr;\n        },\n        and(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other, false).inner();\n            return (0, exports._Expr)(_expr.and(expr));\n        },\n        arccos() {\n            return (0, exports._Expr)(_expr.arccos());\n        },\n        arccosh() {\n            return (0, exports._Expr)(_expr.arccosh());\n        },\n        arcsin() {\n            return (0, exports._Expr)(_expr.arcsin());\n        },\n        arcsinh() {\n            return (0, exports._Expr)(_expr.arcsinh());\n        },\n        arctan() {\n            return (0, exports._Expr)(_expr.arctan());\n        },\n        arctanh() {\n            return (0, exports._Expr)(_expr.arctanh());\n        },\n        argMax() {\n            return (0, exports._Expr)(_expr.argMax());\n        },\n        argMin() {\n            return (0, exports._Expr)(_expr.argMin());\n        },\n        argSort(reverse = false, maintain_order) {\n            reverse = reverse?.reverse ?? reverse;\n            maintain_order = reverse?.maintain_order ?? maintain_order;\n            return (0, exports._Expr)(_expr.argSort(reverse, false, false, maintain_order));\n        },\n        argUnique() {\n            return (0, exports._Expr)(_expr.argUnique());\n        },\n        as(name) {\n            return (0, exports._Expr)(_expr.alias(name));\n        },\n        backwardFill() {\n            return (0, exports._Expr)(_expr.backwardFill());\n        },\n        cast(dtype, strict = false) {\n            return (0, exports._Expr)(_expr.cast(dtype, strict));\n        },\n        ceil() {\n            return (0, exports._Expr)(_expr.ceil());\n        },\n        clip(arg, max) {\n            if (typeof arg === \"number\") {\n                return (0, exports._Expr)(_expr.clip((0, exports.exprToLitOrExpr)(arg)._expr, (0, exports.exprToLitOrExpr)(max)._expr));\n            }\n            return (0, exports._Expr)(_expr.clip((0, exports.exprToLitOrExpr)(arg.min)._expr, (0, exports.exprToLitOrExpr)(arg.max)._expr));\n        },\n        cos() {\n            return (0, exports._Expr)(_expr.cos());\n        },\n        cosh() {\n            return (0, exports._Expr)(_expr.cosh());\n        },\n        cot() {\n            return (0, exports._Expr)(_expr.cot());\n        },\n        count() {\n            return (0, exports._Expr)(_expr.count());\n        },\n        cumCount(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumCount(reverse?.reverse ?? reverse));\n        },\n        cumMax(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumMax(reverse));\n        },\n        cumMin(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumMin(reverse));\n        },\n        cumProd(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumProd(reverse));\n        },\n        cumSum(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumSum(reverse));\n        },\n        diff(n, nullBehavior = \"ignore\") {\n            if (typeof n === \"number\") {\n                return (0, exports._Expr)(_expr.diff(n, nullBehavior));\n            }\n            return (0, exports._Expr)(_expr.diff(n.n, n.nullBehavior));\n        },\n        dot(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other, false).inner();\n            return (0, exports._Expr)(_expr.dot(expr));\n        },\n        ewmMean(opts, adjust, minPeriods, bias, ignoreNulls) {\n            if (opts) {\n                if (typeof opts === \"number\") {\n                    return wrap(\"ewmMean\", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);\n                }\n                return wrap(\"ewmMean\", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);\n            }\n            return wrap(\"ewmMean\", 0.5, true, 1, false, true);\n        },\n        ewmStd(opts, adjust, minPeriods, bias, ignoreNulls) {\n            if (opts) {\n                if (typeof opts === \"number\") {\n                    return wrap(\"ewmStd\", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);\n                }\n                return wrap(\"ewmStd\", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);\n            }\n            return wrap(\"ewmStd\", 0.5, true, 1, false, true);\n        },\n        ewmVar(opts, adjust, minPeriods, bias, ignoreNulls) {\n            if (opts) {\n                if (typeof opts === \"number\") {\n                    return wrap(\"ewmVar\", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);\n                }\n                return wrap(\"ewmVar\", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);\n            }\n            return wrap(\"ewmVar\", 0.5, true, 1, false, true);\n        },\n        exclude(...columns) {\n            return (0, exports._Expr)(_expr.exclude(columns.flat(2)));\n        },\n        explode() {\n            return (0, exports._Expr)(_expr.explode());\n        },\n        exp() {\n            return (0, exports._Expr)(_expr.exp());\n        },\n        extend(o, n) {\n            if (n !== null && typeof n === \"number\") {\n                return (0, exports._Expr)(_expr.extendConstant(o, n));\n            }\n            return (0, exports._Expr)(_expr.extendConstant(o.value, o.n));\n        },\n        extendConstant(o, n) {\n            if (n !== null && typeof n === \"number\") {\n                return (0, exports._Expr)(_expr.extendConstant(o, n));\n            }\n            return (0, exports._Expr)(_expr.extendConstant(o.value, o.n));\n        },\n        fillNan(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other, true).inner();\n            return (0, exports._Expr)(_expr.fillNan(expr));\n        },\n        fillNull(fillValue) {\n            if ([\"backward\", \"forward\", \"mean\", \"min\", \"max\", \"zero\", \"one\"].includes(fillValue)) {\n                return (0, exports._Expr)(_expr.fillNullWithStrategy(fillValue));\n            }\n            const expr = (0, exports.exprToLitOrExpr)(fillValue).inner();\n            return (0, exports._Expr)(_expr.fillNull(expr));\n        },\n        filter(predicate) {\n            const expr = (0, exports.exprToLitOrExpr)(predicate).inner();\n            return (0, exports._Expr)(_expr.filter(expr));\n        },\n        first() {\n            return (0, exports._Expr)(_expr.first());\n        },\n        flatten() {\n            return (0, exports._Expr)(_expr.explode());\n        },\n        floor() {\n            return (0, exports._Expr)(_expr.floor());\n        },\n        forwardFill() {\n            return (0, exports._Expr)(_expr.forwardFill());\n        },\n        gather(indices) {\n            if (Array.isArray(indices)) {\n                indices = polars_internal_1.default.lit((0, series_1.Series)(indices).inner());\n            }\n            else {\n                indices = indices.inner();\n            }\n            return wrap(\"gather\", indices);\n        },\n        gatherEvery(n, offset = 0) {\n            return (0, exports._Expr)(_expr.gatherEvery(n, offset));\n        },\n        hash(obj = 0, k1 = 1, k2 = 2, k3 = 3) {\n            if (typeof obj === \"number\" || typeof obj === \"bigint\") {\n                return wrap(\"hash\", BigInt(obj), BigInt(k1), BigInt(k2), BigInt(k3));\n            }\n            const o = { k0: obj, k1: k1, k2: k2, k3: k3, ...obj };\n            return wrap(\"hash\", BigInt(o.k0), BigInt(o.k1), BigInt(o.k2), BigInt(o.k3));\n        },\n        head(length) {\n            if (typeof length === \"number\") {\n                return wrap(\"head\", length);\n            }\n            return wrap(\"head\", length.length);\n        },\n        interpolate(method = \"linear\") {\n            return (0, exports._Expr)(_expr.interpolate(method));\n        },\n        isDuplicated() {\n            return (0, exports._Expr)(_expr.isDuplicated());\n        },\n        isFinite() {\n            return (0, exports._Expr)(_expr.isFinite());\n        },\n        isInfinite() {\n            return (0, exports._Expr)(_expr.isInfinite());\n        },\n        isFirstDistinct() {\n            return (0, exports._Expr)(_expr.isFirstDistinct());\n        },\n        isNan() {\n            return (0, exports._Expr)(_expr.isNan());\n        },\n        isNotNan() {\n            return (0, exports._Expr)(_expr.isNotNan());\n        },\n        isNotNull() {\n            return (0, exports._Expr)(_expr.isNotNull());\n        },\n        isNull() {\n            return (0, exports._Expr)(_expr.isNull());\n        },\n        isUnique() {\n            return (0, exports._Expr)(_expr.isUnique());\n        },\n        isIn(other) {\n            if (Array.isArray(other)) {\n                other = polars_internal_1.default.lit((0, series_1.Series)(other).inner());\n            }\n            else {\n                other = (0, exports.exprToLitOrExpr)(other, false).inner();\n            }\n            return wrap(\"isIn\", other);\n        },\n        keepName() {\n            return (0, exports._Expr)(_expr.keepName());\n        },\n        kurtosis(obj, bias = true) {\n            const fisher = obj?.[\"fisher\"] ?? (typeof obj === \"boolean\" ? obj : true);\n            bias = obj?.[\"bias\"] ?? bias;\n            return (0, exports._Expr)(_expr.kurtosis(fisher, bias));\n        },\n        last() {\n            return (0, exports._Expr)(_expr.last());\n        },\n        list() {\n            return (0, exports._Expr)(_expr.list());\n        },\n        log1p() {\n            console.log(_expr.log1p);\n            return (0, exports._Expr)(_expr.log1p());\n        },\n        log(base) {\n            return (0, exports._Expr)(_expr.log(base ?? Math.E));\n        },\n        lowerBound() {\n            return (0, exports._Expr)(_expr.lowerBound());\n        },\n        peakMax() {\n            return (0, exports._Expr)(_expr.peakMax());\n        },\n        peakMin() {\n            return (0, exports._Expr)(_expr.peakMin());\n        },\n        max() {\n            return (0, exports._Expr)(_expr.max());\n        },\n        mean() {\n            return (0, exports._Expr)(_expr.mean());\n        },\n        median() {\n            return (0, exports._Expr)(_expr.median());\n        },\n        min() {\n            return (0, exports._Expr)(_expr.min());\n        },\n        mode() {\n            return (0, exports._Expr)(_expr.mode());\n        },\n        not() {\n            return (0, exports._Expr)(_expr.not());\n        },\n        nUnique() {\n            return (0, exports._Expr)(_expr.nUnique());\n        },\n        or(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other).inner();\n            return (0, exports._Expr)(_expr.or(expr));\n        },\n        over(...exprs) {\n            const partitionBy = (0, utils_1.selectionToExprList)(exprs, false);\n            return wrap(\"over\", partitionBy);\n        },\n        pow(exponent) {\n            return (0, exports._Expr)(_expr.pow(exponent?.exponent ?? exponent));\n        },\n        prefix(prefix) {\n            return (0, exports._Expr)(_expr.prefix(prefix));\n        },\n        quantile(quantile, interpolation = \"nearest\") {\n            if (exports.Expr.isExpr(quantile)) {\n                quantile = quantile._expr;\n            }\n            else {\n                quantile = polars_internal_1.default.lit(quantile);\n            }\n            return (0, exports._Expr)(_expr.quantile(quantile, interpolation));\n        },\n        rank(method = \"average\", reverse = false) {\n            return (0, exports._Expr)(_expr.rank(method?.method ?? method, method?.reverse ?? reverse));\n        },\n        reinterpret(signed = true) {\n            signed = signed?.signed ?? signed;\n            return (0, exports._Expr)(_expr.reinterpret(signed));\n        },\n        repeatBy(expr) {\n            const e = (0, exports.exprToLitOrExpr)(expr, false)._expr;\n            return (0, exports._Expr)(_expr.repeatBy(e));\n        },\n        replace(old, newValue) {\n            let oldIn = old;\n            let newIn = newValue;\n            if (old && typeof old === \"object\" && !Array.isArray(old)) {\n                oldIn = Object.keys(old[\"old\"]);\n                newIn = Object.values(old[\"old\"]);\n            }\n            return (0, exports._Expr)(_expr.replace((0, exports.exprToLitOrExpr)(oldIn)._expr, (0, exports.exprToLitOrExpr)(newIn)._expr));\n        },\n        replaceStrict(old, newValue, defaultValue, returnDtype) {\n            let oldIn = old;\n            let newIn = newValue;\n            let defIn = defaultValue;\n            if (old && typeof old === \"object\" && !Array.isArray(old)) {\n                oldIn = Object.keys(old[\"old\"]);\n                newIn = Object.values(old[\"old\"]);\n                defIn = old[\"default_\"];\n            }\n            return (0, exports._Expr)(_expr.replaceStrict((0, exports.exprToLitOrExpr)(oldIn)._expr, (0, exports.exprToLitOrExpr)(newIn)._expr, defIn ? (0, exports.exprToLitOrExpr)(defIn)._expr : undefined, returnDtype));\n        },\n        reverse() {\n            return (0, exports._Expr)(_expr.reverse());\n        },\n        rollingMax: rolling(\"rollingMax\"),\n        rollingMean: rolling(\"rollingMean\"),\n        rollingMin: rolling(\"rollingMin\"),\n        rollingSum: rolling(\"rollingSum\"),\n        rollingStd: rolling(\"rollingStd\"),\n        rollingVar: rolling(\"rollingVar\"),\n        rollingMedian: rolling(\"rollingMedian\"),\n        rollingQuantile(val, interpolation, windowSize, weights, minPeriods, center, by, closedWindow, warnIfUnsorted) {\n            if (typeof val === \"number\") {\n                return wrap(\"rollingQuantile\", {\n                    windowSize: `${windowSize}i`,\n                    weights,\n                    minPeriods,\n                    center,\n                });\n            }\n            windowSize =\n                val?.[\"windowSize\"] ?? (typeof val === \"number\" ? val : null);\n            if (windowSize === null) {\n                throw new Error(\"window size is required\");\n            }\n            return wrap(\"rollingQuantile\", val.quantile, val.interpolation ?? \"nearest\", windowSize, val?.[\"weights\"] ?? weights ?? null, val?.[\"minPeriods\"] ?? minPeriods ?? windowSize, val?.[\"center\"] ?? center ?? false, val?.[\"by\"] ?? by, closedWindow, val?.[\"warnIfUnsorted\"] ?? warnIfUnsorted ?? true);\n        },\n        rollingSkew(val, bias = true) {\n            if (typeof val === \"number\") {\n                return wrap(\"rollingSkew\", val, bias);\n            }\n            return wrap(\"rollingSkew\", val.windowSize, val.bias ?? bias);\n        },\n        round(decimals) {\n            return (0, exports._Expr)(_expr.round(decimals?.decimals ?? decimals));\n        },\n        sample(opts, frac, withReplacement = false, seed) {\n            if (opts?.n !== undefined || opts?.frac !== undefined) {\n                return this.sample(opts.n, opts.frac, opts.withReplacement, seed);\n            }\n            if (typeof opts === \"number\") {\n                throw new Error(\"sample_n is not yet supported for expr\");\n            }\n            if (typeof frac === \"number\") {\n                return wrap(\"sampleFrac\", frac, withReplacement, false, seed);\n            }\n            throw new TypeError(\"must specify either 'frac' or 'n'\");\n        },\n        shift(periods) {\n            return (0, exports._Expr)(_expr.shift((0, exports.exprToLitOrExpr)(periods)._expr));\n        },\n        shiftAndFill(optOrPeriods, fillValue) {\n            if (typeof optOrPeriods === \"number\") {\n                return wrap(\"shiftAndFill\", optOrPeriods, fillValue);\n            }\n            return wrap(\"shiftAndFill\", optOrPeriods.periods, optOrPeriods.fillValue);\n        },\n        skew(bias) {\n            return wrap(\"skew\", bias?.bias ?? bias ?? true);\n        },\n        sin() {\n            return (0, exports._Expr)(_expr.sin());\n        },\n        sinh() {\n            return (0, exports._Expr)(_expr.sinh());\n        },\n        slice(arg, len) {\n            if (typeof arg === \"number\") {\n                return wrap(\"slice\", polars_internal_1.default.lit(arg), polars_internal_1.default.lit(len));\n            }\n            return wrap(\"slice\", polars_internal_1.default.lit(arg.offset), polars_internal_1.default.lit(arg.length));\n        },\n        sort(reverse = false, nullsLast = false, maintain_order = false) {\n            if (typeof reverse === \"boolean\") {\n                return wrap(\"sortWith\", reverse, nullsLast, false, maintain_order);\n            }\n            return wrap(\"sortWith\", reverse?.reverse ?? false, reverse?.nullsLast ?? nullsLast, false, reverse?.maintain_order ?? maintain_order);\n        },\n        sortBy(arg, reverse = false) {\n            if (arg?.by !== undefined) {\n                return this.sortBy(arg.by, arg.reverse);\n            }\n            reverse = Array.isArray(reverse) ? reverse.flat() : [reverse];\n            const by = (0, utils_1.selectionToExprList)(arg, false);\n            return wrap(\"sortBy\", by, reverse);\n        },\n        std() {\n            return (0, exports._Expr)(_expr.std());\n        },\n        suffix(suffix) {\n            return (0, exports._Expr)(_expr.suffix(suffix));\n        },\n        sum() {\n            return (0, exports._Expr)(_expr.sum());\n        },\n        tail(length) {\n            return (0, exports._Expr)(_expr.tail(length));\n        },\n        tan() {\n            return (0, exports._Expr)(_expr.tan());\n        },\n        tanh() {\n            return (0, exports._Expr)(_expr.tanh());\n        },\n        unique(opt) {\n            if (opt || opt?.maintainOrder) {\n                return wrap(\"uniqueStable\");\n            }\n            return wrap(\"unique\");\n        },\n        upperBound() {\n            return (0, exports._Expr)(_expr.upperBound());\n        },\n        where(expr) {\n            return this.filter(expr);\n        },\n        var() {\n            return (0, exports._Expr)(_expr.var());\n        },\n        add: wrapExprArg(\"add\"),\n        sub: wrapExprArg(\"sub\"),\n        div: wrapExprArg(\"div\"),\n        mul: wrapExprArg(\"mul\"),\n        rem: wrapExprArg(\"rem\"),\n        plus: wrapExprArg(\"add\"),\n        minus: wrapExprArg(\"sub\"),\n        divideBy: wrapExprArg(\"div\"),\n        multiplyBy: wrapExprArg(\"mul\"),\n        modulo: wrapExprArg(\"rem\"),\n        eq: wrapExprArg(\"eq\"),\n        equals: wrapExprArg(\"eq\"),\n        gtEq: wrapExprArg(\"gtEq\"),\n        greaterThanEquals: wrapExprArg(\"gtEq\"),\n        gt: wrapExprArg(\"gt\"),\n        greaterThan: wrapExprArg(\"gt\"),\n        ltEq: wrapExprArg(\"ltEq\"),\n        lessThanEquals: wrapExprArg(\"ltEq\"),\n        lt: wrapExprArg(\"lt\"),\n        lessThan: wrapExprArg(\"lt\"),\n        neq: wrapExprArg(\"neq\"),\n        notEquals: wrapExprArg(\"neq\"),\n    };\n}",
  "DataFrame": "function DataFrameConstructor(data, options) {\n    if (!data) {\n        return (0, exports._DataFrame)(objToDF({}));\n    }\n    if (Array.isArray(data)) {\n        return (0, exports._DataFrame)((0, construction_1.arrayToJsDataFrame)(data, options));\n    }\n    return (0, exports._DataFrame)(objToDF(data, options));\n}",
  "LazyDataFrame": "(_ldf) => {\n    const unwrap = (method, ...args) => {\n        return _ldf[method](...args);\n    };\n    const wrap = (method, ...args) => {\n        return (0, exports._LazyDataFrame)(unwrap(method, ...args));\n    };\n    return {\n        _ldf,\n        [inspect]() {\n            return _ldf.describeOptimizedPlan();\n        },\n        get [Symbol.toStringTag]() {\n            return \"LazyDataFrame\";\n        },\n        get columns() {\n            return _ldf.columns;\n        },\n        describePlan() {\n            return _ldf.describePlan();\n        },\n        describeOptimizedPlan() {\n            return _ldf.describeOptimizedPlan();\n        },\n        cache() {\n            return (0, exports._LazyDataFrame)(_ldf.cache());\n        },\n        clone() {\n            return (0, exports._LazyDataFrame)(_ldf.clone());\n        },\n        collectSync() {\n            return (0, dataframe_1._DataFrame)(_ldf.collectSync());\n        },\n        collect(opts) {\n            if (opts?.noOptimization) {\n                opts.predicatePushdown = false;\n                opts.projectionPushdown = false;\n                opts.slicePushdown = false;\n                opts.commSubplanElim = false;\n                opts.commSubexprElim = false;\n            }\n            if (opts?.streaming)\n                opts.commSubplanElim = false;\n            if (opts) {\n                _ldf = _ldf.optimizationToggle(opts.typeCoercion, opts.predicatePushdown, opts.projectionPushdown, opts.simplifyExpression, opts.slicePushdown, opts.commSubplanElim, opts.commSubexprElim, opts.streaming);\n            }\n            return _ldf.collect().then(dataframe_1._DataFrame);\n        },\n        drop(...cols) {\n            return (0, exports._LazyDataFrame)(_ldf.dropColumns(cols.flat(2)));\n        },\n        distinct(...args) {\n            return (0, exports._LazyDataFrame)(_ldf.unique(...args));\n        },\n        unique(opts = false, subset, keep = \"first\") {\n            const defaultOptions = {\n                maintainOrder: false,\n                keep: \"first\",\n            };\n            if (typeof opts === \"boolean\") {\n                const o = { ...defaultOptions, maintainOrder: opts, subset, keep };\n                return (0, exports._LazyDataFrame)(_ldf.unique(o.maintainOrder, o?.subset?.flat(2), o.keep));\n            }\n            if (opts.subset) {\n                opts.subset = [opts.subset].flat(3);\n            }\n            const o = { ...defaultOptions, ...opts };\n            return (0, exports._LazyDataFrame)(_ldf.unique(o.maintainOrder, o.subset, o.keep));\n        },\n        dropNulls(...subset) {\n            if (subset.length) {\n                return wrap(\"dropNulls\", subset.flat(2));\n            }\n            return wrap(\"dropNulls\");\n        },\n        explode(...columns) {\n            if (!columns.length) {\n                const cols = (0, utils_1.selectionToExprList)(_ldf.columns, false);\n                return wrap(\"explode\", cols);\n            }\n            const column = (0, utils_1.selectionToExprList)(columns, false);\n            return wrap(\"explode\", column);\n        },\n        fetchSync(numRows, opts) {\n            if (opts?.noOptimization) {\n                opts.predicatePushdown = false;\n                opts.projectionPushdown = false;\n                opts.slicePushdown = false;\n                opts.commSubplanElim = false;\n                opts.commSubexprElim = false;\n            }\n            if (opts?.streaming)\n                opts.commSubplanElim = false;\n            if (opts) {\n                _ldf = _ldf.optimizationToggle(opts.typeCoercion, opts.predicatePushdown, opts.projectionPushdown, opts.simplifyExpr, opts.slicePushdown, opts.commSubplanElim, opts.commSubexprElim, opts.streaming);\n            }\n            return (0, dataframe_1._DataFrame)(_ldf.fetchSync(numRows));\n        },\n        fetch(numRows, opts) {\n            if (opts?.noOptimization) {\n                opts.predicatePushdown = false;\n                opts.projectionPushdown = false;\n                opts.slicePushdown = false;\n                opts.commSubplanElim = false;\n                opts.commSubexprElim = false;\n            }\n            if (opts?.streaming)\n                opts.commSubplanElim = false;\n            if (opts) {\n                _ldf = _ldf.optimizationToggle(opts.typeCoercion, opts.predicatePushdown, opts.projectionPushdown, opts.simplifyExpr, opts.slicePushdown, opts.commSubplanElim, opts.commSubexprElim, opts.streaming);\n            }\n            return _ldf.fetch(numRows).then(dataframe_1._DataFrame);\n        },\n        first() {\n            return this.fetchSync(1);\n        },\n        fillNull(exprOrValue) {\n            const fillValue = (0, expr_1.exprToLitOrExpr)(exprOrValue)._expr;\n            return (0, exports._LazyDataFrame)(_ldf.fillNull(fillValue));\n        },\n        filter(exprOrValue) {\n            const predicate = (0, expr_1.exprToLitOrExpr)(exprOrValue, false)._expr;\n            return (0, exports._LazyDataFrame)(_ldf.filter(predicate));\n        },\n        groupBy(opt, maintainOrder = true) {\n            if (opt?.by !== undefined) {\n                const by = (0, utils_1.selectionToExprList)([opt.by], false);\n                return (0, groupby_1._LazyGroupBy)(_ldf.groupby(by, opt.maintainOrder));\n            }\n            const by = (0, utils_1.selectionToExprList)([opt], false);\n            return (0, groupby_1._LazyGroupBy)(_ldf.groupby(by, maintainOrder));\n        },\n        groupByRolling({ indexColumn, by, period, offset, closed, check_sorted }) {\n            offset = offset ?? `-${period}`;\n            closed = closed ?? \"right\";\n            by = prepareGroupbyInputs(by);\n            check_sorted = check_sorted ?? false;\n            const lgb = _ldf.groupbyRolling(polars_internal_1.default.col(indexColumn), period, offset, closed, by, check_sorted);\n            return (0, groupby_1._LazyGroupBy)(lgb);\n        },\n        groupByDynamic({ indexColumn, every, period, offset, includeBoundaries, closed, by, start_by, check_sorted, }) {\n            period = period ?? every;\n            offset = offset ?? `-${period}`;\n            closed = closed ?? \"right\";\n            by = prepareGroupbyInputs(by);\n            includeBoundaries = includeBoundaries ?? false;\n            start_by = start_by ?? \"monday\";\n            check_sorted = check_sorted ?? false;\n            const lgb = _ldf.groupbyDynamic(polars_internal_1.default.col(indexColumn), every, period, offset, includeBoundaries, closed, by, start_by, check_sorted);\n            return (0, groupby_1._LazyGroupBy)(lgb);\n        },\n        head(len = 5) {\n            return (0, exports._LazyDataFrame)(_ldf.slice(0, len));\n        },\n        inner() {\n            return _ldf;\n        },\n        join(df, options) {\n            options = {\n                how: \"inner\",\n                suffix: \"right\",\n                allowParallel: true,\n                forceParallel: false,\n                ...options,\n            };\n            const { how, suffix, allowParallel, forceParallel } = options;\n            if (how === \"cross\") {\n                return (0, exports._LazyDataFrame)(_ldf.join(df._ldf, [], [], allowParallel, forceParallel, how, suffix, [], []));\n            }\n            let leftOn;\n            let rightOn;\n            if (options.on) {\n                const on = (0, utils_1.selectionToExprList)(options.on, false);\n                leftOn = on;\n                rightOn = on;\n            }\n            else if ((options.leftOn && !options.rightOn) ||\n                (options.rightOn && !options.leftOn)) {\n                throw new TypeError(\"You should pass the column to join on as an argument.\");\n            }\n            else {\n                leftOn = (0, utils_1.selectionToExprList)(options.leftOn, false);\n                rightOn = (0, utils_1.selectionToExprList)(options.rightOn, false);\n            }\n            const ldf = _ldf.join(df._ldf, leftOn, rightOn, allowParallel, forceParallel, how, suffix, [], []);\n            return (0, exports._LazyDataFrame)(ldf);\n        },\n        joinAsof(other, options) {\n            options = {\n                suffix: \"_right\",\n                allowParallel: true,\n                forceParallel: false,\n                strategy: \"backward\",\n                ...options,\n            };\n            const { suffix, strategy, allowParallel, forceParallel } = options;\n            let leftOn;\n            let rightOn;\n            if (!other?._ldf) {\n                throw new TypeError(\"Expected a 'lazyFrame' as join table\");\n            }\n            if (options.on) {\n                leftOn = rightOn = options.on;\n            }\n            else if ((options.leftOn && !options.rightOn) ||\n                (options.rightOn && !options.leftOn)) {\n                throw new TypeError(\"You should pass the column to join on as an argument.\");\n            }\n            else {\n                leftOn = options.leftOn;\n                rightOn = options.rightOn;\n            }\n            let byLeft;\n            if (typeof options.byLeft === \"string\") {\n                byLeft = [options.byLeft];\n            }\n            else if (Array.isArray(options.byLeft)) {\n                byLeft = options.byLeft;\n            }\n            let byRight;\n            if (typeof options.byRight === \"string\") {\n                byRight = [options.byRight];\n            }\n            else if (Array.isArray(options.byRight)) {\n                byRight = options.byRight;\n            }\n            if (typeof options.by === \"string\") {\n                byLeft = byRight = [options.by];\n            }\n            else if (Array.isArray(options.by)) {\n                byLeft = byRight = options.by;\n            }\n            let toleranceStr;\n            let toleranceNum;\n            if (typeof options.tolerance === \"string\") {\n                toleranceStr = options.tolerance;\n            }\n            else {\n                toleranceNum = options.tolerance;\n            }\n            const ldf = _ldf.joinAsof(other._ldf, polars_internal_1.default.col(leftOn), polars_internal_1.default.col(rightOn), byLeft, byRight, allowParallel, forceParallel, suffix, strategy, toleranceNum, toleranceStr);\n            return (0, exports._LazyDataFrame)(ldf);\n        },\n        last() {\n            return (0, exports._LazyDataFrame)(_ldf.tail(1));\n        },\n        limit(len = 5) {\n            return (0, exports._LazyDataFrame)(_ldf.slice(0, len));\n        },\n        max() {\n            return (0, exports._LazyDataFrame)(_ldf.max());\n        },\n        mean() {\n            return (0, exports._LazyDataFrame)(_ldf.mean());\n        },\n        median() {\n            return (0, exports._LazyDataFrame)(_ldf.median());\n        },\n        melt(ids, values) {\n            return (0, exports._LazyDataFrame)(_ldf.unpivot((0, utils_1.columnOrColumnsStrict)(ids), (0, utils_1.columnOrColumnsStrict)(values)));\n        },\n        unpivot(ids, values) {\n            return (0, exports._LazyDataFrame)(_ldf.unpivot((0, utils_1.columnOrColumnsStrict)(ids), (0, utils_1.columnOrColumnsStrict)(values)));\n        },\n        min() {\n            return (0, exports._LazyDataFrame)(_ldf.min());\n        },\n        quantile(quantile, interpolation = \"nearest\") {\n            return (0, exports._LazyDataFrame)(_ldf.quantile(quantile, interpolation));\n        },\n        rename(mapping) {\n            const existing = Object.keys(mapping);\n            const replacements = Object.values(mapping);\n            return (0, exports._LazyDataFrame)(_ldf.rename(existing, replacements));\n        },\n        reverse() {\n            return (0, exports._LazyDataFrame)(_ldf.reverse());\n        },\n        select(...exprs) {\n            const selections = (0, utils_1.selectionToExprList)(exprs, false);\n            return (0, exports._LazyDataFrame)(_ldf.select(selections));\n        },\n        shift(periods) {\n            return (0, exports._LazyDataFrame)(_ldf.shift(periods));\n        },\n        shiftAndFill(opts, fillValue) {\n            if (typeof opts === \"number\") {\n                return (0, exports._LazyDataFrame)(_ldf.shiftAndFill(opts, fillValue));\n            }\n            return (0, exports._LazyDataFrame)(_ldf.shiftAndFill(opts?.n, opts?.fillValue));\n        },\n        slice(opt, len) {\n            if (opt?.offset !== undefined) {\n                return (0, exports._LazyDataFrame)(_ldf.slice(opt.offset, opt.length));\n            }\n            return (0, exports._LazyDataFrame)(_ldf.slice(opt, len));\n        },\n        sort(arg, descending = false, nulls_last = false, maintain_order = false) {\n            if (arg?.by !== undefined) {\n                return this.sort(arg.by, arg.descending, arg.nulls_last, arg.maintain_order);\n            }\n            if (typeof arg === \"string\") {\n                return wrap(\"sort\", arg, descending, nulls_last, maintain_order);\n            }\n            const by = (0, utils_1.selectionToExprList)(arg, false);\n            return wrap(\"sortByExprs\", by, descending, nulls_last, maintain_order);\n        },\n        std() {\n            return (0, exports._LazyDataFrame)(_ldf.std());\n        },\n        sum() {\n            return (0, exports._LazyDataFrame)(_ldf.sum());\n        },\n        var() {\n            return (0, exports._LazyDataFrame)(_ldf.var());\n        },\n        tail(length = 5) {\n            return (0, exports._LazyDataFrame)(_ldf.tail(length));\n        },\n        toJSON(...args) {\n            // this is passed by `JSON.stringify` when calling `toJSON()`\n            if (args[0] === \"\") {\n                return JSON.parse(_ldf.serialize(\"json\").toString());\n            }\n            return _ldf.serialize(\"json\").toString();\n        },\n        serialize(format) {\n            return _ldf.serialize(format);\n        },\n        withColumn(expr) {\n            return (0, exports._LazyDataFrame)(_ldf.withColumn(expr._expr));\n        },\n        withColumns(...columns) {\n            const exprs = (0, utils_1.selectionToExprList)(columns, false);\n            return (0, exports._LazyDataFrame)(_ldf.withColumns(exprs));\n        },\n        withColumnRenamed(existing, replacement) {\n            return (0, exports._LazyDataFrame)(_ldf.rename([existing], [replacement]));\n        },\n        withRowCount(name = \"row_nr\") {\n            return (0, exports._LazyDataFrame)(_ldf.withRowCount(name));\n        },\n        sinkCSV(path, options = {}) {\n            options.maintainOrder = options.maintainOrder ?? false;\n            _ldf.sinkCsv(path, options);\n        },\n        sinkParquet(path, options = {}) {\n            options.compression = options.compression ?? \"zstd\";\n            options.statistics = options.statistics ?? false;\n            _ldf.sinkParquet(path, options);\n        },\n    };\n}",
  "Series": "(arg0, arg1, dtype, strict) => {\n    if (typeof arg0 === \"string\") {\n        const _s = (0, construction_1.arrayToJsSeries)(arg0, arg1, dtype, strict);\n        return _Series(_s);\n    }\n    return SeriesConstructor(\"\", arg0);\n}",
  "Config": {
    "setUtf8Tables": "setUtf8Tables() {\n        process.env[\"POLARS_FMT_NO_UTF8\"] = undefined;\n        return this;\n    }",
    "setAsciiTables": "setAsciiTables() {\n        process.env[\"POLARS_FMT_NO_UTF8\"] = \"1\";\n        return this;\n    }",
    "setTblWidthChars": "setTblWidthChars(width) {\n        process.env[\"POLARS_TABLE_WIDTH\"] = String(width);\n        return this;\n    }",
    "setTblRows": "setTblRows(n) {\n        process.env[\"POLARS_FMT_MAX_ROWS\"] = String(n);\n        return this;\n    }",
    "setTblCols": "setTblCols(n) {\n        process.env[\"POLARS_FMT_MAX_COLS\"] = String(n);\n        return this;\n    }",
    "setGlobalStringCache": "setGlobalStringCache() {\n        native_polars_1.default.toggleStringCache(true);\n        return this;\n    }",
    "unsetGlobalStringCache": "unsetGlobalStringCache() {\n        native_polars_1.default.toggleStringCache(false);\n        return this;\n    }"
  },
  "Field": "class Field {\n    name;\n    dtype;\n    constructor(name, dtype) {\n        this.name = name;\n        this.dtype = dtype;\n    }\n    toString() {\n        return `Field(\"${this.name}\", ${this.dtype})`;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            dtype: this.dtype,\n        };\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.toJSON();\n    }\n}",
  "repeat": "function repeat(value, n, name = \"\") {\n    const dtype = (0, construction_1.jsTypeToPolarsType)(value);\n    const s = polars_internal_1.default.JsSeries.repeat(name, value, n, dtype);\n    return (0, series_1._Series)(s);\n}",
  "concat": "function concat(items, options = { rechunk: true, how: \"vertical\" }) {\n    const { rechunk, how } = options;\n    if (!items.length) {\n        throw new RangeError(\"cannot concat empty list\");\n    }\n    if ((0, utils_1.isDataFrameArray)(items)) {\n        let df;\n        switch (how) {\n            case \"vertical\":\n                df = items.reduce((acc, curr) => acc.vstack(curr));\n                break;\n            case \"horizontal\":\n                df = (0, dataframe_1._DataFrame)(polars_internal_1.default.horizontalConcat(items.map((i) => i.inner())));\n                break;\n            case \"diagonal\":\n                df = (0, dataframe_1._DataFrame)(polars_internal_1.default.diagonalConcat(items.map((i) => i.inner())));\n                break;\n            default:\n                throw new TypeError(\"unknown concat how option\");\n        }\n        return rechunk ? df.rechunk() : df;\n    }\n    if ((0, utils_1.isLazyDataFrameArray)(items)) {\n        const df = (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.concatLf(items.map((i) => i.inner()), how, rechunk));\n        return df;\n    }\n    if ((0, utils_1.isSeriesArray)(items)) {\n        const s = items.reduce((acc, curr) => acc.concat(curr));\n        return rechunk ? s.rechunk() : s;\n    }\n    throw new TypeError(\"can only concat series and dataframes\");\n}",
  "scanCSV": "function scanCSV(path, options) {\n    options = { ...scanCsvDefaultOptions, ...options };\n    return (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.scanCsv(path, options));\n}",
  "scanJson": "function scanJson(path, options) {\n    options = { ...readJsonDefaultOptions, ...options };\n    return (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.scanJson(path, options));\n}",
  "scanIPC": "function scanIPC(path, options = {}) {\n    return (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.scanIpc(path, options));\n}",
  "scanParquet": "function scanParquet(source, options = {}) {\n    const defaultOptions = { parallel: \"auto\" };\n    const pliOptions = { ...defaultOptions, ...options };\n    return (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.scanParquet(source, pliOptions));\n}",
  "readRecords": "function readRecords(records, options) {\n    if (options?.schema) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.fromRows(records, options.schema));\n    }\n    return (0, dataframe_1._DataFrame)(polars_internal_1.default.fromRows(records, undefined, options?.inferSchemaLength));\n}",
  "readCSV": "function readCSV(pathOrBody, options) {\n    options = { ...readCsvDefaultOptions, ...options };\n    const extensions = [\".tsv\", \".csv\"];\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readCsv(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, extensions);\n        if (inline) {\n            const buf = Buffer.from(pathOrBody, \"utf-8\");\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readCsv(buf, options));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readCsv(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
  "readIPC": "function readIPC(pathOrBody, options = {}) {\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpc(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, [\".ipc\"]);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpc(Buffer.from(pathOrBody, \"utf-8\"), options));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpc(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
  "readIPCStream": "function readIPCStream(pathOrBody, options = {}) {\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpcStream(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, [\".ipc\"]);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpcStream(Buffer.from(pathOrBody, \"utf-8\"), options));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpcStream(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
  "readJSON": "function readJSON(pathOrBody, options = readJsonDefaultOptions) {\n    options = { ...readJsonDefaultOptions, ...options };\n    const method = options.format === \"lines\" ? polars_internal_1.default.readJsonLines : polars_internal_1.default.readJson;\n    const extensions = [\".ndjson\", \".json\", \".jsonl\"];\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readJson(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, extensions);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(method(Buffer.from(pathOrBody, \"utf-8\"), options));\n        }\n        return (0, dataframe_1._DataFrame)(method(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
  "readParquet": "function readParquet(pathOrBody, options) {\n    const pliOptions = {};\n    if (typeof options?.columns?.[0] === \"number\") {\n        pliOptions.projection = options?.columns;\n    }\n    else {\n        pliOptions.columns = options?.columns;\n    }\n    pliOptions.nRows = options?.numRows;\n    pliOptions.rowCount = options?.rowCount;\n    const parallel = options?.parallel ?? \"auto\";\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readParquet(pathOrBody, pliOptions, parallel));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, [\".parquet\"]);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readParquet(Buffer.from(pathOrBody), pliOptions, parallel));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readParquet(pathOrBody, pliOptions, parallel));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
  "readAvro": "function readAvro(pathOrBody, options = {}) {\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readAvro(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, [\".avro\"]);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readAvro(Buffer.from(pathOrBody), options));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readAvro(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
  "readCSVStream": "function readCSVStream(stream, options) {\n    const batchSize = options?.batchSize ?? 10000;\n    let count = 0;\n    const end = options?.endRows ?? Number.POSITIVE_INFINITY;\n    return new Promise((resolve, reject) => {\n        const s = stream.pipe(new LineBatcher({ batchSize }));\n        const chunks = [];\n        s.on(\"data\", (chunk) => {\n            // early abort if 'end rows' is specified\n            if (count <= end) {\n                chunks.push(chunk);\n            }\n            else {\n                s.end();\n            }\n            count += batchSize;\n        }).on(\"end\", () => {\n            try {\n                const buff = Buffer.concat(chunks);\n                const df = readCSVBuffer(buff, options);\n                resolve(df);\n            }\n            catch (err) {\n                reject(err);\n            }\n        });\n    });\n}",
  "readJSONStream": "function readJSONStream(stream, options = readJsonDefaultOptions) {\n    options = { ...readJsonDefaultOptions, ...options };\n    return new Promise((resolve, reject) => {\n        const chunks = [];\n        stream\n            .pipe(new LineBatcher({ batchSize: options.batchSize }))\n            .on(\"data\", (chunk) => {\n            try {\n                const df = (0, dataframe_1._DataFrame)(polars_internal_1.default.readJson(chunk, options));\n                chunks.push(df);\n            }\n            catch (err) {\n                reject(err);\n            }\n        })\n            .on(\"end\", () => {\n            try {\n                const df = (0, functions_1.concat)(chunks);\n                resolve(df);\n            }\n            catch (err) {\n                reject(err);\n            }\n        });\n    });\n}",
  "col": "function col(col) {\n    if (series_1.Series.isSeries(col)) {\n        col = col.toArray();\n    }\n    if (Array.isArray(col)) {\n        return (0, expr_1._Expr)(polars_internal_1.default.cols(col));\n    }\n    if (typeof col === \"object\" && Object.values(col)[0] === \"DataType\") {\n        return (0, expr_1._Expr)(polars_internal_1.default.dtypeCols([col]));\n    }\n    return (0, expr_1._Expr)(polars_internal_1.default.col(col));\n}",
  "cols": "function cols(...cols) {\n    return col(cols.flat());\n}",
  "lit": "function lit(value) {\n    if (Array.isArray(value)) {\n        value = (0, series_1.Series)(value);\n    }\n    if (series_1.Series.isSeries(value)) {\n        return (0, expr_1._Expr)(polars_internal_1.default.lit(value.inner()));\n    }\n    return (0, expr_1._Expr)(polars_internal_1.default.lit(value));\n}",
  "intRange": "function intRange(opts, end, step = 1, dtype = datatypes_1.DataType.Int64, eager) {\n    // @deprecated since 0.15.0\n    if (typeof opts?.low === \"number\") {\n        return intRange(opts.low, opts.high, opts.step, opts.dtype, opts.eager);\n    }\n    if (typeof opts?.start === \"number\") {\n        return intRange(opts.start, opts.end, opts.step, opts.dtype, opts.eager);\n    }\n    // if expression like pl.len() passed\n    if (end === undefined || end === null) {\n        end = opts;\n        opts = 0;\n    }\n    const start = (0, expr_1.exprToLitOrExpr)(opts, false);\n    end = (0, expr_1.exprToLitOrExpr)(end, false);\n    if (eager) {\n        const df = (0, dataframe_1.DataFrame)({ a: [1] });\n        return df\n            .select(intRange(start, end, step).alias(\"intRange\"))\n            .getColumn(\"intRange\");\n    }\n    return (0, expr_1._Expr)(polars_internal_1.default.intRange(start, end, step, dtype));\n}",
  "intRanges": "function intRanges(start, end, step = 1, dtype = datatypes_1.DataType.Int64, eager) {\n    start = (0, expr_1.exprToLitOrExpr)(start, false);\n    end = (0, expr_1.exprToLitOrExpr)(end, false);\n    step = (0, expr_1.exprToLitOrExpr)(step, false);\n    if (eager) {\n        const df = (0, dataframe_1.DataFrame)({ a: [1] });\n        return df\n            .select(intRanges(start, end, step, dtype).alias(\"intRanges\"))\n            .getColumn(\"intRanges\");\n    }\n    return (0, expr_1._Expr)(polars_internal_1.default.intRanges(start, end, step, dtype));\n}",
  "argSortBy": "function argSortBy(exprs, descending = false) {\n    if (!Array.isArray(descending)) {\n        descending = Array.from({ length: exprs.length }, () => descending);\n    }\n    const by = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.argSortBy(by, descending));\n}",
  "avg": "function avg(column) {\n    return mean(column);\n}",
  "concatList": "function concatList(...exprs) {\n    const items = (0, utils_1.selectionToExprList)(exprs, false);\n    return expr_1.Expr(polars_internal_1.default.concatLst(items));\n}",
  "concatString": "function concatString(opts, sep = \",\", ignoreNulls = true) {\n    if (opts?.exprs) {\n        return concatString(opts.exprs, opts.sep, opts.ignoreNulls);\n    }\n    const items = (0, utils_1.selectionToExprList)(opts, false);\n    return expr_1.Expr(polars_internal_1.default.concatStr(items, sep, ignoreNulls));\n}",
  "count": "function count(column) {\n    if (series_1.Series.isSeries(column)) {\n        return column.len();\n    }\n    return col(column).count();\n}",
  "cov": "function cov(a, b, ddof = 1) {\n    a = (0, expr_1.exprToLitOrExpr)(a, false);\n    b = (0, expr_1.exprToLitOrExpr)(b, false);\n    return (0, expr_1._Expr)(polars_internal_1.default.cov(a, b, ddof));\n}",
  "exclude": "function exclude(...columns) {\n    return col(\"*\").exclude(columns);\n}",
  "element": "function element() {\n    return col(\"\");\n}",
  "first": "function first(column) {\n    if (!column) {\n        return (0, expr_1._Expr)(polars_internal_1.default.first());\n    }\n    if (series_1.Series.isSeries(column)) {\n        if (column.length) {\n            return column.get(0);\n        }\n        throw new RangeError(\"The series is empty, so no first value can be returned.\");\n    }\n    return col(column).first();\n}",
  "format": "function format(strings, ...expr) {\n    if (typeof strings === \"string\") {\n        const s = strings.split(\"{}\");\n        if (s.length - 1 !== expr.length) {\n            throw new RangeError(\"number of placeholders should equal the number of arguments\");\n        }\n        return format(s, ...expr);\n    }\n    const d = (0, utils_1.range)(0, Math.max(strings.length, expr.length))\n        .flatMap((i) => {\n        const sVal = strings[i] ? lit(strings[i]) : [];\n        const exprVal = expr[i] ? (0, expr_1.exprToLitOrExpr)(expr[i], false) : [];\n        return [sVal, exprVal];\n    })\n        .flat();\n    return concatString(d, \"\");\n}",
  "groups": "function groups(column) {\n    return col(column).aggGroups();\n}",
  "head": "function head(column, n) {\n    if (series_1.Series.isSeries(column)) {\n        return column.head(n);\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).head(n);\n}",
  "last": "function last(column) {\n    if (series_1.Series.isSeries(column)) {\n        if (column.length) {\n            return column.get(-1);\n        }\n        throw new RangeError(\"The series is empty, so no last value can be returned.\");\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).last();\n}",
  "mean": "function mean(column) {\n    if (series_1.Series.isSeries(column)) {\n        return column.mean();\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).mean();\n}",
  "median": "function median(column) {\n    if (series_1.Series.isSeries(column)) {\n        return column.median();\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).median();\n}",
  "nUnique": "function nUnique(column) {\n    if (series_1.Series.isSeries(column)) {\n        return column.nUnique();\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).nUnique();\n}",
  "pearsonCorr": "function pearsonCorr(a, b) {\n    a = (0, expr_1.exprToLitOrExpr)(a, false);\n    b = (0, expr_1.exprToLitOrExpr)(b, false);\n    return (0, expr_1._Expr)(polars_internal_1.default.pearsonCorr(a, b));\n}",
  "quantile": "function quantile(column, q) {\n    if (series_1.Series.isSeries(column)) {\n        return column.quantile(q);\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).quantile(q);\n}",
  "select": "function select(expr, ...exprs) {\n    return (0, dataframe_1.DataFrame)({}).select(expr, ...exprs);\n}",
  "struct": "function struct(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    if (series_1.Series.isSeries(exprs[0])) {\n        return select((0, expr_1._Expr)(polars_internal_1.default.asStruct(exprs.map((e) => polars_internal_1.default.lit(e.inner()))))).toSeries();\n    }\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.asStruct(exprs));\n}",
  "allHorizontal": "function allHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.allHorizontal(exprs));\n}",
  "anyHorizontal": "function anyHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.anyHorizontal(exprs));\n}",
  "minHorizontal": "function minHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.minHorizontal(exprs));\n}",
  "maxHorizontal": "function maxHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.maxHorizontal(exprs));\n}",
  "sumHorizontal": "function sumHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.sumHorizontal(exprs));\n}",
  "spearmanRankCorr": "function spearmanRankCorr(a, b) {\n    a = (0, expr_1.exprToLitOrExpr)(a, false);\n    b = (0, expr_1.exprToLitOrExpr)(b, false);\n    return (0, expr_1._Expr)(polars_internal_1.default.spearmanRankCorr(a, b, null, false));\n}",
  "tail": "function tail(column, n) {\n    if (series_1.Series.isSeries(column)) {\n        return column.tail(n);\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).tail(n);\n}",
  "list": "function list(column) {\n    return (0, expr_1.exprToLitOrExpr)(column, false).list();\n}",
  "when": "function when(expr) {\n    return When(polars_internal_1.default.when(expr._expr));\n}",
  "version": "0.16.0",
  "Categorical": {
    "identity": "DataType"
  },
  "Int8": {
    "identity": "DataType"
  },
  "Int16": {
    "identity": "DataType"
  },
  "Int32": {
    "identity": "DataType"
  },
  "Int64": {
    "identity": "DataType"
  },
  "UInt8": {
    "identity": "DataType"
  },
  "UInt16": {
    "identity": "DataType"
  },
  "UInt32": {
    "identity": "DataType"
  },
  "UInt64": {
    "identity": "DataType"
  },
  "Float32": {
    "identity": "DataType"
  },
  "Float64": {
    "identity": "DataType"
  },
  "Bool": {
    "identity": "DataType"
  },
  "Utf8": {
    "identity": "DataType"
  },
  "String": {
    "identity": "DataType"
  },
  "List": "List(inner) {\n        return new List(inner);\n    }",
  "FixedSizeList": "FixedSizeList(inner, listSize) {\n        return new FixedSizeList(inner, listSize);\n    }",
  "Date": {
    "identity": "DataType"
  },
  "Datetime": "Datetime(timeUnit, timeZone = null) {\n        return new Datetime(timeUnit ?? \"ms\", timeZone);\n    }",
  "Time": {
    "identity": "DataType"
  },
  "Object": {
    "identity": "DataType"
  },
  "Null": {
    "identity": "DataType"
  },
  "Struct": "Struct(fields) {\n        return new Struct(fields);\n    }",
  "Decimal": "Decimal(precision, scale) {\n        return new Decimal(precision, scale);\n    }",
  "SQLContext": "function SQLContext(frames) {\n    return new sql.SQLContext(frames);\n}",
  "_Series": "function _Series(_s) {\n    const unwrap = (method, ...args) => {\n        return _s[method](...args);\n    };\n    const wrap = (method, ...args) => {\n        return _Series(unwrap(method, ...args));\n    };\n    const dtypeWrap = (method, ...args) => {\n        const dtype = _s.dtype;\n        const dt = datatypes_1.DTYPE_TO_FFINAME[dtype];\n        const internalMethod = `series${method}${dt}`;\n        return _Series(polars_internal_1.default[internalMethod](_s, ...args));\n    };\n    const dtypeUnwrap = (method, ...args) => {\n        const dtype = _s.dtype;\n        const dt = datatypes_1.DTYPE_TO_FFINAME[dtype];\n        const internalMethod = `series${method}${dt}`;\n        return polars_internal_1.default[internalMethod](_s, ...args);\n    };\n    const expr_op = (method, ...args) => {\n        return _Series(_s)\n            .toFrame()\n            .select((0, functions_1.col)(_s.name)[method](...args))\n            .getColumn(_s.name);\n    };\n    const series = {\n        _s,\n        [inspect]() {\n            return _s.toString();\n        },\n        *[Symbol.iterator]() {\n            let start = 0;\n            const len = _s.len();\n            while (start < len) {\n                const v = _s.getIdx(start);\n                start++;\n                yield v;\n            }\n        },\n        toString() {\n            return _s.toString();\n        },\n        serialize(format) {\n            return _s.serialize(format);\n        },\n        [Symbol.toStringTag]() {\n            return \"Series\";\n        },\n        get dtype() {\n            return datatypes_1.DataType.deserialize(_s.dtype);\n        },\n        get name() {\n            return _s.name;\n        },\n        get length() {\n            return _s.len();\n        },\n        get str() {\n            return (0, string_1.SeriesStringFunctions)(_s);\n        },\n        get lst() {\n            return (0, list_1.SeriesListFunctions)(_s);\n        },\n        get date() {\n            return (0, datetime_1.SeriesDateFunctions)(_s);\n        },\n        get struct() {\n            return (0, struct_1.SeriesStructFunctions)(_s);\n        },\n        abs() {\n            return wrap(\"abs\");\n        },\n        add(field) {\n            return dtypeWrap(\"Add\", field);\n        },\n        alias(name) {\n            const s = _s.clone();\n            s.rename(name);\n            return _Series(s);\n        },\n        append(other) {\n            _s.append(other.inner());\n        },\n        argMax() {\n            return _s.argMax();\n        },\n        argMin() {\n            return _s.argMin();\n        },\n        argSort(reverse = false, nullsLast = true, multithreaded = true, maintainOrder = false) {\n            if (typeof reverse === \"boolean\") {\n                return _Series(_s.argsort(reverse, nullsLast, multithreaded, maintainOrder));\n            }\n            return _Series(_s.argsort(reverse.reverse, reverse.nullsLast ?? nullsLast, reverse.multithreaded ?? multithreaded, reverse.maintainOrder ?? maintainOrder));\n        },\n        argTrue() {\n            return _Series(this.toFrame()\n                ._df.lazy()\n                .select([polars_internal_1.default.argWhere(polars_internal_1.default.col(this.name))])\n                .collectSync()\n                .column(this.name));\n        },\n        argUnique() {\n            return _Series(_s.argUnique());\n        },\n        as(name) {\n            return this.alias(name);\n        },\n        bitand(other) {\n            return _Series(_s.bitand(other._s));\n        },\n        bitor(other) {\n            return _Series(_s.bitor(other._s));\n        },\n        bitxor(other) {\n            return _Series(_s.bitxor(other._s));\n        },\n        cast(dtype, strict = false) {\n            return _Series(_s.cast(dtype, strict));\n        },\n        chunkLengths() {\n            return _s.chunkLengths();\n        },\n        clone() {\n            return _Series(_s.clone());\n        },\n        concat(other) {\n            const s = _s.clone();\n            s.append(other.inner());\n            return _Series(s);\n        },\n        cumCount(reverse) {\n            return expr_op(\"cumCount\", reverse);\n        },\n        cumSum(reverse) {\n            return _Series(_s.cumSum(reverse));\n        },\n        cumMax(reverse) {\n            return _Series(_s.cumMax(reverse));\n        },\n        cumMin(reverse) {\n            return _Series(_s.cumMin(reverse));\n        },\n        cumProd(reverse) {\n            return _Series(_s.cumProd(reverse));\n        },\n        describe() {\n            let s = this.clone();\n            let stats = {};\n            if (!this.length) {\n                throw new RangeError(\"Series must contain at least one value\");\n            }\n            if (this.isNumeric()) {\n                s = s.cast(datatypes_1.DataType.Float64);\n                stats = {\n                    min: s.min(),\n                    max: s.max(),\n                    null_count: s.nullCount(),\n                    mean: s.mean(),\n                    count: s.len(),\n                };\n            }\n            else if (s.isBoolean()) {\n                stats = {\n                    sum: s.sum(),\n                    null_count: s.nullCount(),\n                    count: s.len(),\n                };\n            }\n            else if (s.isString()) {\n                stats = {\n                    unique: s.nUnique(),\n                    null_count: s.nullCount(),\n                    count: s.len(),\n                };\n            }\n            else {\n                throw new error_1.InvalidOperationError(\"describe\", s.dtype);\n            }\n            return (0, dataframe_1.DataFrame)({\n                statistic: Object.keys(stats),\n                value: Object.values(stats),\n            });\n        },\n        diff(n = 1, nullBehavior = \"ignore\") {\n            return typeof n === \"number\"\n                ? _Series(_s.diff(n, nullBehavior))\n                : _Series(_s.diff(n?.n ?? 1, n.nullBehavior ?? nullBehavior));\n        },\n        div(field) {\n            return dtypeWrap(\"Div\", field);\n        },\n        divideBy(field) {\n            return this.div(field);\n        },\n        dot(other) {\n            return wrap(\"dot\", other._s);\n        },\n        dropNulls() {\n            return wrap(\"dropNulls\");\n        },\n        eq(field) {\n            return dtypeWrap(\"Eq\", field);\n        },\n        equals(field) {\n            return this.eq(field);\n        },\n        ewmMean(...args) {\n            return expr_op(\"ewmMean\", ...args);\n        },\n        ewmStd(...args) {\n            return expr_op(\"ewmStd\", ...args);\n        },\n        ewmVar(...args) {\n            return expr_op(\"ewmVar\", ...args);\n        },\n        explode() {\n            return wrap(\"explode\");\n        },\n        extend(value, n) {\n            return wrap(\"extendConstant\", value, n);\n        },\n        extendConstant(value, n) {\n            return wrap(\"extendConstant\", value, n);\n        },\n        fillNull(strategy) {\n            return typeof strategy === \"string\"\n                ? wrap(\"fillNull\", strategy)\n                : wrap(\"fillNull\", strategy.strategy);\n        },\n        filter(predicate) {\n            return exports.Series.isSeries(predicate)\n                ? wrap(\"filter\", predicate._s)\n                : wrap(\"filter\", SeriesConstructor(\"\", predicate)._s);\n        },\n        get(field) {\n            return dtypeUnwrap(\"Get\", field);\n        },\n        getIndex(idx) {\n            return _s.getIdx(idx);\n        },\n        gt(field) {\n            return dtypeWrap(\"Gt\", field);\n        },\n        greaterThan(field) {\n            return this.gt(field);\n        },\n        gtEq(field) {\n            return dtypeWrap(\"GtEq\", field);\n        },\n        greaterThanEquals(field) {\n            return this.gtEq(field);\n        },\n        hash(obj = 0n, k1 = 1n, k2 = 2n, k3 = 3n) {\n            if (typeof obj === \"number\" || typeof obj === \"bigint\") {\n                return wrap(\"hash\", BigInt(obj), BigInt(k1), BigInt(k2), BigInt(k3));\n            }\n            const o = { k0: obj, k1: k1, k2: k2, k3: k3, ...obj };\n            return wrap(\"hash\", BigInt(o.k0), BigInt(o.k1), BigInt(o.k2), BigInt(o.k3));\n        },\n        hasValidity() {\n            return _s.hasValidity();\n        },\n        head(length = 5) {\n            return wrap(\"head\", length);\n        },\n        inner() {\n            return _s;\n        },\n        interpolate() {\n            return expr_op(\"interpolate\");\n        },\n        isBoolean() {\n            const dtype = this.dtype;\n            return dtype.equals(datatypes_1.DataType.Bool);\n        },\n        isDateTime() {\n            const dtype = this.dtype;\n            return [datatypes_1.DataType.Date.variant, \"Datetime\"].includes(dtype.variant);\n        },\n        isDuplicated() {\n            return wrap(\"isDuplicated\");\n        },\n        isFinite() {\n            const dtype = this.dtype;\n            if (![datatypes_1.DataType.Float32.variant, datatypes_1.DataType.Float64.variant].includes(dtype.variant)) {\n                throw new error_1.InvalidOperationError(\"isFinite\", dtype);\n            }\n            return wrap(\"isFinite\");\n        },\n        isFirstDistinct() {\n            return wrap(\"isFirstDistinct\");\n        },\n        isFloat() {\n            const dtype = this.dtype;\n            return [datatypes_1.DataType.Float32.variant, datatypes_1.DataType.Float64.variant].includes(dtype.variant);\n        },\n        isIn(other) {\n            return exports.Series.isSeries(other)\n                ? wrap(\"isIn\", other._s)\n                : wrap(\"isIn\", (0, exports.Series)(\"\", other)._s);\n        },\n        isInfinite() {\n            const dtype = this.dtype;\n            if (![datatypes_1.DataType.Float32.variant, datatypes_1.DataType.Float64.variant].includes(dtype.variant)) {\n                throw new error_1.InvalidOperationError(\"isFinite\", dtype);\n            }\n            return wrap(\"isInfinite\");\n        },\n        isNotNull() {\n            return wrap(\"isNotNull\");\n        },\n        isNull() {\n            return wrap(\"isNull\");\n        },\n        isNaN() {\n            return wrap(\"isNan\");\n        },\n        isNotNaN() {\n            return wrap(\"isNotNan\");\n        },\n        isNumeric() {\n            const dtype = this.dtype;\n            const numericTypes = [\n                datatypes_1.DataType.Int8.variant,\n                datatypes_1.DataType.Int16.variant,\n                datatypes_1.DataType.Int32.variant,\n                datatypes_1.DataType.Int64.variant,\n                datatypes_1.DataType.UInt8.variant,\n                datatypes_1.DataType.UInt16.variant,\n                datatypes_1.DataType.UInt32.variant,\n                datatypes_1.DataType.UInt64.variant,\n                datatypes_1.DataType.Float32.variant,\n                datatypes_1.DataType.Float64.variant,\n            ];\n            return numericTypes.includes(dtype.variant);\n        },\n        isUnique() {\n            return wrap(\"isUnique\");\n        },\n        isString() {\n            return this.dtype.equals(datatypes_1.DataType.String);\n        },\n        isUtf8() {\n            return this.dtype.equals(datatypes_1.DataType.Utf8);\n        },\n        kurtosis(fisher = true, bias = true) {\n            if (typeof fisher === \"boolean\") {\n                return _s.kurtosis(fisher, bias);\n            }\n            const d = {\n                fisher: true,\n                bias,\n                ...fisher,\n            };\n            return _s.kurtosis(d.fisher, d.bias);\n        },\n        len() {\n            return this.length;\n        },\n        lt(field) {\n            if (typeof field === \"number\")\n                return dtypeWrap(\"Lt\", field);\n            if (exports.Series.isSeries(field)) {\n                return wrap(\"lt\", field._s);\n            }\n            throw new Error(\"Not a number nor a series\");\n        },\n        lessThan(field) {\n            if (typeof field === \"number\")\n                return dtypeWrap(\"Lt\", field);\n            if (exports.Series.isSeries(field)) {\n                return wrap(\"lt\", field._s);\n            }\n            throw new Error(\"Not a number nor a series\");\n        },\n        ltEq(field) {\n            if (typeof field === \"number\")\n                return dtypeWrap(\"LtEq\", field);\n            if (exports.Series.isSeries(field)) {\n                return wrap(\"ltEq\", field._s);\n            }\n            throw new Error(\"Not a number nor a series\");\n        },\n        lessThanEquals(field) {\n            if (typeof field === \"number\")\n                return dtypeWrap(\"LtEq\", field);\n            if (exports.Series.isSeries(field)) {\n                return wrap(\"ltEq\", field._s);\n            }\n            throw new Error(\"Not a number nor a series\");\n        },\n        limit(n = 10) {\n            return wrap(\"limit\", n);\n        },\n        max() {\n            return _s.max();\n        },\n        mean() {\n            return _s.mean();\n        },\n        median() {\n            return _s.median();\n        },\n        min() {\n            return _s.min();\n        },\n        mode() {\n            return wrap(\"mode\");\n        },\n        minus(other) {\n            if (typeof other === \"number\")\n                return dtypeWrap(\"Sub\", other);\n            if (exports.Series.isSeries(other)) {\n                return wrap(\"sub\", other._s);\n            }\n            throw new Error(\"Not a number nor a series\");\n        },\n        mul(other) {\n            if (typeof other === \"number\")\n                return dtypeWrap(\"Mul\", other);\n            if (exports.Series.isSeries(other)) {\n                return wrap(\"mul\", other._s);\n            }\n            throw new Error(\"Not a number nor a series\");\n        },\n        nChunks() {\n            return _s.nChunks();\n        },\n        neq(other) {\n            if (typeof other === \"number\")\n                return dtypeWrap(\"Neq\", other);\n            if (exports.Series.isSeries(other)) {\n                return wrap(\"neq\", other._s);\n            }\n            throw new Error(\"Not a number nor a series\");\n        },\n        notEquals(other) {\n            return this.neq(other);\n        },\n        nullCount() {\n            return _s.nullCount();\n        },\n        nUnique() {\n            return _s.nUnique();\n        },\n        peakMax() {\n            return expr_op(\"peakMax\");\n        },\n        peakMin() {\n            return expr_op(\"peakMin\");\n        },\n        plus(other) {\n            if (typeof other === \"number\")\n                return dtypeWrap(\"Add\", other);\n            if (exports.Series.isSeries(other)) {\n                return wrap(\"add\", other._s);\n            }\n            throw new Error(\"Not a number nor a series\");\n        },\n        quantile(quantile, interpolation = \"nearest\") {\n            return _s.quantile(quantile, interpolation);\n        },\n        rank(method = \"average\", reverse = false) {\n            return wrap(\"rank\", method, reverse);\n        },\n        rechunk(inPlace = false) {\n            return wrap(\"rechunk\", inPlace);\n        },\n        reinterpret(signed = true) {\n            const dtype = this.dtype;\n            if ([datatypes_1.DataType.UInt64.variant, datatypes_1.DataType.Int64.variant].includes(dtype.variant)) {\n                return wrap(\"reinterpret\", signed);\n            }\n            throw new error_1.InvalidOperationError(\"reinterpret\", dtype);\n        },\n        rem(field) {\n            return dtypeWrap(\"Rem\", field);\n        },\n        modulo(field) {\n            return this.rem(field);\n        },\n        rename(obj, inPlace = false) {\n            if (obj?.inPlace ?? inPlace) {\n                _s.rename(obj?.name ?? obj);\n            }\n            else {\n                return this.alias(obj?.name ?? obj);\n            }\n        },\n        rollingMax(...args) {\n            return expr_op(\"rollingMax\", ...args);\n        },\n        rollingMean(...args) {\n            return expr_op(\"rollingMean\", ...args);\n        },\n        rollingMin(...args) {\n            return expr_op(\"rollingMin\", ...args);\n        },\n        rollingSum(...args) {\n            return expr_op(\"rollingSum\", ...args);\n        },\n        rollingStd(...args) {\n            return expr_op(\"rollingStd\", ...args);\n        },\n        rollingVar(...args) {\n            return expr_op(\"rollingVar\", ...args);\n        },\n        rollingMedian(...args) {\n            return expr_op(\"rollingMedian\", ...args);\n        },\n        rollingQuantile(...args) {\n            return expr_op(\"rollingQuantile\", ...args);\n        },\n        rollingSkew(...args) {\n            return expr_op(\"rollingSkew\", ...args);\n        },\n        floor() {\n            return wrap(\"floor\");\n        },\n        ceil() {\n            return wrap(\"ceil\");\n        },\n        round(opt) {\n            if (this.isNumeric()) {\n                if (typeof opt === \"number\") {\n                    return wrap(\"round\", opt);\n                }\n                return wrap(\"round\", opt.decimals);\n            }\n            throw new error_1.InvalidOperationError(\"round\", this.dtype);\n        },\n        clip(...args) {\n            return expr_op(\"clip\", ...args);\n        },\n        setAtIdx(indices, value) {\n            _s.scatter(indices, value);\n        },\n        scatter(indices, value) {\n            indices = exports.Series.isSeries(indices)\n                ? indices.cast(datatypes_1.DataType.UInt32)\n                : (0, exports.Series)(indices);\n            if (!exports.Series.isSeries(value)) {\n                if (!Array.isArray(value)) {\n                    value = [value];\n                }\n                value = (0, exports.Series)(value);\n            }\n            if (indices.length > 0) {\n                value = value.extendConstant(value[0], indices.length - 1);\n            }\n            _s.scatter(indices._s, value._s);\n        },\n        set(mask, value) {\n            mask = exports.Series.isSeries(mask) ? mask : exports.Series.from(mask);\n            return dtypeWrap(\"SetWithMask\", mask.inner(), value);\n        },\n        sample(opts, frac, withReplacement = false, seed) {\n            // biome-ignore lint/style/noArguments: <explanation>\n            if (arguments.length === 0) {\n                return wrap(\"sampleN\", 1, withReplacement, false, seed);\n            }\n            if (opts?.n !== undefined || opts?.frac !== undefined) {\n                return this.sample(opts.n, opts.frac, opts.withReplacement, seed);\n            }\n            if (typeof opts === \"number\") {\n                return wrap(\"sampleN\", opts, withReplacement, false, seed);\n            }\n            if (typeof frac === \"number\") {\n                return wrap(\"sampleFrac\", frac, withReplacement, false, seed);\n            }\n            throw new TypeError(\"must specify either 'frac' or 'n'\");\n        },\n        seriesEqual(other, nullEqual = true, strict = false) {\n            return _s.seriesEqual(other._s, nullEqual, strict);\n        },\n        shift(periods = 1) {\n            return wrap(\"shift\", periods);\n        },\n        shiftAndFill(...args) {\n            return expr_op(\"shiftAndFill\", ...args);\n        },\n        shrinkToFit(inPlace) {\n            if (inPlace) {\n                _s.shrinkToFit();\n            }\n            else {\n                const s = this.clone();\n                s.shrinkToFit();\n                return s;\n            }\n        },\n        skew(bias = true) {\n            if (typeof bias === \"boolean\") {\n                return _s.skew(bias);\n            }\n            return _s.skew(bias?.bias ?? true);\n        },\n        slice(offset, length) {\n            if (typeof offset === \"number\") {\n                return wrap(\"slice\", offset, length);\n            }\n            return wrap(\"slice\", offset.offset, offset.length);\n        },\n        sort(options) {\n            options = { descending: false, nullsLast: false, ...(options ?? {}) };\n            return wrap(\"sort\", options.descending, options.nullsLast);\n        },\n        sub(field) {\n            return dtypeWrap(\"Sub\", field);\n        },\n        sum() {\n            return _s.sum();\n        },\n        tail(length = 5) {\n            return wrap(\"tail\", length);\n        },\n        gather(indices) {\n            return wrap(\"take\", indices);\n        },\n        gatherEvery(n, offset) {\n            return wrap(\"gatherEvery\", n, offset ?? 0);\n        },\n        multiplyBy(field) {\n            return this.mul(field);\n        },\n        toArray() {\n            return _s.toArray();\n        },\n        toTypedArray() {\n            if (!this.hasValidity() || this.nullCount() === 0) {\n                return _s.toTypedArray();\n            }\n            throw new Error(\"data contains nulls, unable to convert to TypedArray\");\n        },\n        toDummies(separator = \"_\", dropFirst = false) {\n            return (0, dataframe_1._DataFrame)(_s.toDummies(separator, dropFirst));\n        },\n        toFrame() {\n            return (0, dataframe_1._DataFrame)(new polars_internal_1.default.JsDataFrame([_s]));\n        },\n        toBinary() {\n            return _s.toBinary();\n        },\n        toJSON(...args) {\n            // this is passed by `JSON.stringify` when calling `toJSON()`\n            if (args[0] === \"\") {\n                return _s.toJs();\n            }\n            return _s.serialize(\"json\").toString();\n        },\n        toObject() {\n            return _s.toJs();\n        },\n        unique(maintainOrder) {\n            if (maintainOrder) {\n                return wrap(\"uniqueStable\");\n            }\n            return wrap(\"unique\");\n        },\n        valueCounts(sort, parallel, name, normalize) {\n            name = name ?? (normalize ? \"proportion\" : \"count\");\n            return (0, dataframe_1._DataFrame)(unwrap(\"valueCounts\", sort ?? false, parallel ?? false, name, normalize ?? false));\n        },\n        values() {\n            return this[Symbol.iterator]();\n        },\n        zipWith(mask, other) {\n            return wrap(\"zipWith\", mask._s, other._s);\n        },\n    };\n    return new Proxy(series, {\n        get: (target, prop, receiver) => {\n            if (typeof prop !== \"symbol\" && !Number.isNaN(Number(prop))) {\n                return target.get(Number(prop));\n            }\n            return Reflect.get(target, prop, receiver);\n        },\n        set: (series, prop, input) => {\n            if (typeof prop !== \"symbol\" && !Number.isNaN(Number(prop))) {\n                series.scatter([Number(prop)], input);\n                return true;\n            }\n        },\n    });\n}",
  "_DataFrame": "(_df) => {\n    const unwrap = (method, ...args) => {\n        return _df[method](...args);\n    };\n    const wrap = (method, ...args) => {\n        return (0, exports._DataFrame)(unwrap(method, ...args));\n    };\n    const df = {\n        /** @ignore */\n        _df,\n        [inspect]() {\n            return _df.toString();\n        },\n        *[Symbol.iterator]() {\n            let start = 0;\n            const len = this.width;\n            while (start < len) {\n                const s = this.toSeries(start);\n                start++;\n                yield s;\n            }\n        },\n        get [Symbol.toStringTag]() {\n            return \"DataFrame\";\n        },\n        get dtypes() {\n            return _df.dtypes().map(datatypes_1.DataType.deserialize);\n        },\n        get height() {\n            return _df.height;\n        },\n        get width() {\n            return _df.width;\n        },\n        get shape() {\n            return _df.shape;\n        },\n        get columns() {\n            return _df.columns;\n        },\n        set columns(names) {\n            _df.columns = names;\n        },\n        /**\n         * Return back text/html and application/vnd.dataresource+json representations\n         * of the DataFrame. This is intended to be a simple view of the DataFrame\n         * inside of notebooks.\n         *\n         * @returns Media bundle / mimetype keys for Jupyter frontends\n         */\n        [jupyterDisplay]() {\n            let rows = 50;\n            if (process.env.POLARS_FMT_MAX_ROWS) {\n                rows = Number.parseInt(process.env.POLARS_FMT_MAX_ROWS);\n            }\n            const limited = this.limit(rows);\n            return {\n                \"application/vnd.dataresource+json\": limited.toDataResource(),\n                \"text/html\": limited.toHTML(),\n            };\n        },\n        get schema() {\n            return this.getColumns().reduce((acc, curr) => {\n                acc[curr.name] = curr.dtype;\n                return acc;\n            }, {});\n        },\n        clone() {\n            return wrap(\"clone\");\n        },\n        describe() {\n            const describeCast = (df) => {\n                return (0, exports.DataFrame)(df.getColumns().map((s) => {\n                    if (s.isNumeric() || s.isBoolean()) {\n                        return s.cast(datatypes_1.DataType.Float64);\n                    }\n                    return s;\n                }));\n            };\n            const summary = (0, functions_1.concat)([\n                describeCast(this.mean()),\n                describeCast(this.std()),\n                describeCast(this.min()),\n                describeCast(this.max()),\n                describeCast(this.median()),\n            ]);\n            summary.insertAtIdx(0, (0, series_1.Series)(\"describe\", [\"mean\", \"std\", \"min\", \"max\", \"median\"]));\n            return summary;\n        },\n        inner() {\n            return _df;\n        },\n        drop(...names) {\n            if (!Array.isArray(names[0]) && names.length === 1) {\n                return wrap(\"drop\", names[0]);\n            }\n            const df = this.clone();\n            for (const name of names.flat(2)) {\n                df.inner().dropInPlace(name);\n            }\n            return df;\n        },\n        dropNulls(...subset) {\n            if (subset.length) {\n                return wrap(\"dropNulls\", subset.flat(2));\n            }\n            return wrap(\"dropNulls\");\n        },\n        distinct(opts = false, subset, keep = \"first\") {\n            return this.unique(opts, subset);\n        },\n        unique(opts = false, subset, keep = \"first\") {\n            const defaultOptions = {\n                maintainOrder: false,\n                keep,\n            };\n            if (typeof opts === \"boolean\") {\n                return wrap(\"unique\", opts, subset, keep);\n            }\n            if (opts.subset) {\n                opts.subset = [opts.subset].flat(3);\n            }\n            const o = { ...defaultOptions, ...opts };\n            return wrap(\"unique\", o.maintainOrder, o.subset, o.keep);\n        },\n        explode(...columns) {\n            return (0, exports._DataFrame)(_df)\n                .lazy()\n                .explode(columns)\n                .collectSync({ noOptimization: true });\n        },\n        extend(other) {\n            return wrap(\"extend\", other.inner());\n        },\n        filter(predicate) {\n            return this.lazy().filter(predicate).collectSync();\n        },\n        fillNull(strategy) {\n            return wrap(\"fillNull\", strategy);\n        },\n        findIdxByName(name) {\n            return unwrap(\"findIdxByName\", name);\n        },\n        fold(fn) {\n            if (this.width === 1) {\n                return this.toSeries(0);\n            }\n            return this.getColumns().reduce((acc, curr) => fn(acc, curr));\n        },\n        frameEqual(other, nullEqual = true) {\n            return unwrap(\"frameEqual\", other._df, nullEqual);\n        },\n        getColumn(name) {\n            return (0, series_1._Series)(_df.column(name));\n        },\n        getColumns() {\n            return _df.getColumns().map(series_1._Series);\n        },\n        groupBy(...by) {\n            return (0, groupby_1._GroupBy)(_df, (0, utils_1.columnOrColumnsStrict)(by));\n        },\n        groupByRolling(opts) {\n            return (0, groupby_1.RollingGroupBy)((0, exports._DataFrame)(_df), opts.indexColumn, opts.period, opts.offset, opts.closed, opts.by, opts.check_sorted);\n        },\n        groupByDynamic({ indexColumn, every, period, offset, includeBoundaries, closed, by, }) {\n            return (0, groupby_1.DynamicGroupBy)((0, exports._DataFrame)(_df), indexColumn, every, period, offset, includeBoundaries, closed, by);\n        },\n        upsample(opts, every, by, maintainOrder) {\n            let timeColumn;\n            if (typeof opts === \"string\") {\n                timeColumn = opts;\n            }\n            else {\n                timeColumn = opts.timeColumn;\n                by = opts.by;\n                every = opts.every;\n                maintainOrder = opts.maintainOrder ?? false;\n            }\n            if (typeof by === \"string\") {\n                by = [by];\n            }\n            else {\n                by = by ?? [];\n            }\n            return (0, exports._DataFrame)(_df.upsample(by, timeColumn, every, maintainOrder));\n        },\n        hashRows(obj = 0n, k1 = 1n, k2 = 2n, k3 = 3n) {\n            if (typeof obj === \"number\" || typeof obj === \"bigint\") {\n                return (0, series_1._Series)(_df.hashRows(BigInt(obj), BigInt(k1), BigInt(k2), BigInt(k3)));\n            }\n            const o = { k0: obj, k1: k1, k2: k2, k3: k3, ...obj };\n            return (0, series_1._Series)(_df.hashRows(BigInt(o.k0), BigInt(o.k1), BigInt(o.k2), BigInt(o.k3)));\n        },\n        head(length = 5) {\n            return wrap(\"head\", length);\n        },\n        hstack(columns, inPlace = false) {\n            if (!Array.isArray(columns)) {\n                columns = columns.getColumns();\n            }\n            const method = inPlace ? \"hstackMut\" : \"hstack\";\n            return wrap(method, columns.map((col) => col.inner()));\n        },\n        insertAtIdx(idx, series) {\n            _df.insertAtIdx(idx, series.inner());\n        },\n        interpolate() {\n            return this.select((0, functions_2.col)(\"*\").interpolate());\n        },\n        isDuplicated: () => (0, series_1._Series)(_df.isDuplicated()),\n        isEmpty: () => _df.height === 0,\n        isUnique: () => (0, series_1._Series)(_df.isUnique()),\n        join(other, options) {\n            options = { how: \"inner\", ...options };\n            const on = (0, utils_1.columnOrColumns)(options.on);\n            const how = options.how;\n            const suffix = options.suffix;\n            if (how === \"cross\") {\n                return (0, exports._DataFrame)(_df.join(other._df, [], [], how, suffix));\n            }\n            let leftOn = (0, utils_1.columnOrColumns)(options.leftOn);\n            let rightOn = (0, utils_1.columnOrColumns)(options.rightOn);\n            if (on) {\n                leftOn = on;\n                rightOn = on;\n            }\n            if ((leftOn && !rightOn) || (rightOn && !leftOn)) {\n                throw new TypeError(\"You should pass the column to join on as an argument.\");\n            }\n            return wrap(\"join\", other._df, leftOn, rightOn, how, suffix);\n        },\n        joinAsof(other, options) {\n            return this.lazy()\n                .joinAsof(other.lazy(), options)\n                .collectSync();\n        },\n        lazy: () => (0, dataframe_1._LazyDataFrame)(_df.lazy()),\n        limit: (length = 5) => wrap(\"head\", length),\n        max(axis = 0) {\n            if (axis === 1) {\n                return (0, series_1._Series)(_df.hmax());\n            }\n            return this.lazy().max().collectSync();\n        },\n        mean(axis = 0, nullStrategy = \"ignore\") {\n            if (axis === 1) {\n                return (0, series_1._Series)(_df.hmean(nullStrategy));\n            }\n            return this.lazy().mean().collectSync();\n        },\n        median() {\n            return this.lazy().median().collectSync();\n        },\n        melt(ids, values) {\n            return wrap(\"unpivot\", (0, utils_1.columnOrColumns)(ids), (0, utils_1.columnOrColumns)(values));\n        },\n        unpivot(ids, values) {\n            return wrap(\"unpivot\", (0, utils_1.columnOrColumns)(ids), (0, utils_1.columnOrColumns)(values));\n        },\n        min(axis = 0) {\n            if (axis === 1) {\n                return (0, series_1._Series)(_df.hmin());\n            }\n            return this.lazy().min().collectSync();\n        },\n        nChunks() {\n            return _df.nChunks();\n        },\n        nullCount() {\n            return wrap(\"nullCount\");\n        },\n        partitionBy(by, strict = false, includeKey = true, mapFn = (df) => df) {\n            by = Array.isArray(by) ? by : [by];\n            return _df\n                .partitionBy(by, strict, includeKey)\n                .map((d) => mapFn((0, exports._DataFrame)(d)));\n        },\n        pivot(values, options) {\n            let { values: values_, index, on, maintainOrder = true, sortColumns = false, aggregateFunc = \"first\", separator, } = options;\n            values = values_ ?? values;\n            values = typeof values === \"string\" ? [values] : values;\n            index = typeof index === \"string\" ? [index] : index;\n            on = typeof on === \"string\" ? [on] : on;\n            let fn;\n            if (expr_1.Expr.isExpr(aggregateFunc)) {\n                fn = aggregateFunc;\n            }\n            else {\n                fn =\n                    {\n                        first: (0, functions_2.element)().first(),\n                        sum: (0, functions_2.element)().sum(),\n                        max: (0, functions_2.element)().max(),\n                        min: (0, functions_2.element)().min(),\n                        mean: (0, functions_2.element)().mean(),\n                        median: (0, functions_2.element)().median(),\n                        last: (0, functions_2.element)().last(),\n                        count: (0, functions_2.element)().count(),\n                    }[aggregateFunc] ??\n                        new Error(`Unknown aggregate function ${aggregateFunc}`);\n                if (fn instanceof Error) {\n                    throw fn;\n                }\n            }\n            return (0, exports._DataFrame)(_df.pivotExpr(values, on, index, fn, maintainOrder, sortColumns, separator));\n        },\n        quantile(quantile) {\n            return this.lazy().quantile(quantile).collectSync();\n        },\n        rechunk() {\n            return wrap(\"rechunk\");\n        },\n        rename(mapping) {\n            const df = this.clone();\n            for (const [column, new_col] of Object.entries(mapping)) {\n                df.inner().rename(column, new_col);\n            }\n            return df;\n        },\n        replaceAtIdx(index, newColumn) {\n            _df.replaceAtIdx(index, newColumn.inner());\n            return this;\n        },\n        rows(callback) {\n            if (callback) {\n                return _df.toRowsCb(callback);\n            }\n            return _df.toRows();\n        },\n        sample(opts, frac, withReplacement = false, seed) {\n            // biome-ignore lint/style/noArguments: <explanation>\n            if (arguments.length === 0) {\n                return wrap(\"sampleN\", (0, series_1.Series)(\"\", [1]).inner(), withReplacement, false, seed);\n            }\n            if (opts?.n !== undefined || opts?.frac !== undefined) {\n                return this.sample(opts.n, opts.frac, opts.withReplacement, seed);\n            }\n            if (typeof opts === \"number\") {\n                return wrap(\"sampleN\", (0, series_1.Series)(\"\", [opts]).inner(), withReplacement, false, seed);\n            }\n            if (typeof frac === \"number\") {\n                return wrap(\"sampleFrac\", (0, series_1.Series)(\"\", [frac]).inner(), withReplacement, false, seed);\n            }\n            throw new TypeError(\"must specify either 'frac' or 'n'\");\n        },\n        select(...selection) {\n            const hasExpr = selection.flat().some((s) => expr_1.Expr.isExpr(s));\n            if (hasExpr) {\n                return (0, exports._DataFrame)(_df).lazy().select(selection).collectSync();\n            }\n            return wrap(\"select\", (0, utils_1.columnOrColumnsStrict)(selection));\n        },\n        shift: (opt) => wrap(\"shift\", opt?.periods ?? opt),\n        shiftAndFill(n, fillValue) {\n            if (typeof n === \"number\" && fillValue) {\n                return (0, exports._DataFrame)(_df).lazy().shiftAndFill(n, fillValue).collectSync();\n            }\n            return (0, exports._DataFrame)(_df)\n                .lazy()\n                .shiftAndFill(n.n, n.fillValue)\n                .collectSync();\n        },\n        shrinkToFit(inPlace = false) {\n            if (inPlace) {\n                _df.shrinkToFit();\n            }\n            else {\n                const d = this.clone();\n                d.inner().shrinkToFit();\n                return d;\n            }\n        },\n        slice(opts, length) {\n            if (typeof opts === \"number\") {\n                return wrap(\"slice\", opts, length);\n            }\n            return wrap(\"slice\", opts.offset, opts.length);\n        },\n        sort(arg, descending = false, nulls_last = false, maintain_order = false) {\n            if (arg?.by !== undefined) {\n                return this.sort(arg.by, arg.descending, arg.nulls_last, arg.maintain_order);\n            }\n            if (Array.isArray(arg) || expr_1.Expr.isExpr(arg)) {\n                return (0, exports._DataFrame)(_df)\n                    .lazy()\n                    .sort(arg, descending, nulls_last, maintain_order)\n                    .collectSync({ noOptimization: true });\n            }\n            return wrap(\"sort\", arg, descending, nulls_last, maintain_order);\n        },\n        std() {\n            return this.lazy().std().collectSync();\n        },\n        sum(axis = 0, nullStrategy = \"ignore\") {\n            if (axis === 1) {\n                return (0, series_1._Series)(_df.hsum(nullStrategy));\n            }\n            return this.lazy().sum().collectSync();\n        },\n        tail: (length = 5) => wrap(\"tail\", length),\n        serialize(format) {\n            return _df.serialize(format);\n        },\n        toCSV(...args) {\n            return this.writeCSV(...args);\n        },\n        writeCSV(dest, options = {}) {\n            if (dest instanceof node_stream_1.Writable || typeof dest === \"string\") {\n                return _df.writeCsv(dest, options);\n            }\n            const buffers = [];\n            const writeStream = new node_stream_1.Stream.Writable({\n                write(chunk, _encoding, callback) {\n                    buffers.push(chunk);\n                    callback(null);\n                },\n            });\n            _df.writeCsv(writeStream, dest ?? options);\n            writeStream.end(\"\");\n            return Buffer.concat(buffers);\n        },\n        toRecords() {\n            return _df.toObjects();\n        },\n        toJSON(...args) {\n            // this is passed by `JSON.stringify` when calling `toJSON()`\n            if (args[0] === \"\") {\n                return _df.toJs();\n            }\n            return _df.serialize(\"json\").toString();\n        },\n        toHTML() {\n            let htmlTable = \"<table>\";\n            // Add table headers\n            htmlTable += \"<thead><tr>\";\n            for (const field of this.getColumns()) {\n                htmlTable += `<th>${(0, html_1.escapeHTML)(field.name)}</th>`;\n            }\n            htmlTable += \"</tr></thead>\";\n            // Add table data\n            htmlTable += \"<tbody>\";\n            for (const row of this.toRecords()) {\n                htmlTable += \"<tr>\";\n                for (const field of this.getColumns()) {\n                    htmlTable += `<td>${(0, html_1.escapeHTML)(String(row[field.name]))}</td>`;\n                }\n                htmlTable += \"</tr>\";\n            }\n            htmlTable += \"</tbody></table>\";\n            return htmlTable;\n        },\n        toDataResource() {\n            const data = this.toRecords();\n            const fields = this.getColumns().map((column) => ({\n                name: column.name,\n                type: mapPolarsTypeToJSONSchema(column.dtype),\n            }));\n            return { data, schema: { fields } };\n        },\n        toObject() {\n            return this.getColumns().reduce((acc, curr) => {\n                acc[curr.name] = curr.toArray();\n                return acc;\n            }, {});\n        },\n        writeJSON(dest, options = { format: \"lines\" }) {\n            if (dest instanceof node_stream_1.Writable || typeof dest === \"string\") {\n                return _df.writeJson(dest, options);\n            }\n            const buffers = [];\n            const writeStream = new node_stream_1.Stream.Writable({\n                write(chunk, _encoding, callback) {\n                    buffers.push(chunk);\n                    callback(null);\n                },\n            });\n            _df.writeJson(writeStream, { ...options, ...dest });\n            writeStream.end(\"\");\n            return Buffer.concat(buffers);\n        },\n        toParquet(dest, options) {\n            return this.writeParquet(dest, options);\n        },\n        writeParquet(dest, options = { compression: \"uncompressed\" }) {\n            if (dest instanceof node_stream_1.Writable || typeof dest === \"string\") {\n                return _df.writeParquet(dest, options.compression);\n            }\n            const buffers = [];\n            const writeStream = new node_stream_1.Stream.Writable({\n                write(chunk, _encoding, callback) {\n                    buffers.push(chunk);\n                    callback(null);\n                },\n            });\n            _df.writeParquet(writeStream, dest?.compression ?? options?.compression);\n            writeStream.end(\"\");\n            return Buffer.concat(buffers);\n        },\n        writeAvro(dest, options = { compression: \"uncompressed\" }) {\n            if (dest instanceof node_stream_1.Writable || typeof dest === \"string\") {\n                return _df.writeAvro(dest, options.compression);\n            }\n            const buffers = [];\n            const writeStream = new node_stream_1.Stream.Writable({\n                write(chunk, _encoding, callback) {\n                    buffers.push(chunk);\n                    callback(null);\n                },\n            });\n            _df.writeAvro(writeStream, dest?.compression ?? options?.compression);\n            writeStream.end(\"\");\n            return Buffer.concat(buffers);\n        },\n        toIPC(dest, options) {\n            return this.writeIPC(dest, options);\n        },\n        writeIPC(dest, options = { compression: \"uncompressed\" }) {\n            if (dest instanceof node_stream_1.Writable || typeof dest === \"string\") {\n                return _df.writeIpc(dest, options.compression);\n            }\n            const buffers = [];\n            const writeStream = new node_stream_1.Stream.Writable({\n                write(chunk, _encoding, callback) {\n                    buffers.push(chunk);\n                    callback(null);\n                },\n            });\n            _df.writeIpc(writeStream, dest?.compression ?? options?.compression);\n            writeStream.end(\"\");\n            return Buffer.concat(buffers);\n        },\n        writeIPCStream(dest, options = { compression: \"uncompressed\" }) {\n            if (dest instanceof node_stream_1.Writable || typeof dest === \"string\") {\n                return _df.writeIpcStream(dest, options.compression);\n            }\n            const buffers = [];\n            const writeStream = new node_stream_1.Stream.Writable({\n                write(chunk, _encoding, callback) {\n                    buffers.push(chunk);\n                    callback(null);\n                },\n            });\n            _df.writeIpcStream(writeStream, dest?.compression ?? options?.compression);\n            writeStream.end(\"\");\n            return Buffer.concat(buffers);\n        },\n        toSeries: (index = 0) => (0, series_1._Series)(_df.selectAtIdx(index)),\n        toStruct(name) {\n            return (0, series_1._Series)(_df.toStruct(name));\n        },\n        toString() {\n            return _df.toString();\n        },\n        transpose(options) {\n            const includeHeader = options?.includeHeader ?? false;\n            const headeName = options?.headerName ?? \"column\";\n            const keep_names_as = includeHeader ? headeName : undefined;\n            if (options?.columnNames) {\n                function takeNItems(iterable, n) {\n                    const result = [];\n                    let i = 0;\n                    for (const item of iterable) {\n                        if (i >= n) {\n                            break;\n                        }\n                        result.push(item);\n                        i++;\n                    }\n                    return result;\n                }\n                options.columnNames = Array.isArray(options.columnNames)\n                    ? options.columnNames.slice(0, this.height)\n                    : takeNItems(options.columnNames, this.height);\n            }\n            if (!options?.columnNames) {\n                return wrap(\"transpose\", keep_names_as, undefined);\n            }\n            return wrap(\"transpose\", keep_names_as, options.columnNames);\n        },\n        unnest(names) {\n            names = Array.isArray(names) ? names : [names];\n            return (0, exports._DataFrame)(_df.unnest(names));\n        },\n        var() {\n            return this.lazy().var().collectSync();\n        },\n        map: (fn) => map((0, exports._DataFrame)(_df), fn),\n        row(idx) {\n            return _df.toRow(idx);\n        },\n        vstack: (other) => wrap(\"vstack\", other.inner()),\n        withColumn(column) {\n            if (series_1.Series.isSeries(column)) {\n                return wrap(\"withColumn\", column.inner());\n            }\n            return this.withColumns(column);\n        },\n        withColumns(...columns) {\n            if ((0, utils_1.isSeriesArray)(columns)) {\n                return columns.reduce((acc, curr) => acc.withColumn(curr), (0, exports._DataFrame)(_df));\n            }\n            return this.lazy()\n                .withColumns(columns)\n                .collectSync({ noOptimization: true });\n        },\n        withColumnRenamed(opt, replacement) {\n            if (typeof opt === \"string\") {\n                return this.rename({ [opt]: replacement });\n            }\n            return this.rename({ [opt.existing]: opt.replacement });\n        },\n        withRowCount(name = \"row_nr\") {\n            return wrap(\"withRowCount\", name);\n        },\n        where(predicate) {\n            return this.filter(predicate);\n        },\n        add: (other) => wrap(\"add\", prepareOtherArg(other).inner()),\n        sub: (other) => wrap(\"sub\", prepareOtherArg(other).inner()),\n        div: (other) => wrap(\"div\", prepareOtherArg(other).inner()),\n        mul: (other) => wrap(\"mul\", prepareOtherArg(other).inner()),\n        rem: (other) => wrap(\"rem\", prepareOtherArg(other).inner()),\n        plus: (other) => wrap(\"add\", prepareOtherArg(other).inner()),\n        minus: (other) => wrap(\"sub\", prepareOtherArg(other).inner()),\n        divideBy: (other) => wrap(\"div\", prepareOtherArg(other).inner()),\n        multiplyBy: (other) => wrap(\"mul\", prepareOtherArg(other).inner()),\n        modulo: (other) => wrap(\"rem\", prepareOtherArg(other).inner()),\n    };\n    return new Proxy(df, {\n        get(target, prop, receiver) {\n            if (typeof prop === \"string\" && target.columns.includes(prop)) {\n                return target.getColumn(prop);\n            }\n            if (typeof prop !== \"symbol\" && !Number.isNaN(Number(prop))) {\n                return target.row(Number(prop));\n            }\n            return Reflect.get(target, prop, receiver);\n        },\n        set(target, prop, receiver) {\n            if (series_1.Series.isSeries(receiver)) {\n                if (typeof prop === \"string\" && target.columns.includes(prop)) {\n                    const idx = target.columns.indexOf(prop);\n                    target.replaceAtIdx(idx, receiver.alias(prop));\n                    return true;\n                }\n            }\n            Reflect.set(target, prop, receiver);\n            return true;\n        },\n        has(target, p) {\n            if (p === jupyterDisplay) {\n                return true;\n            }\n            return target.columns.includes(p);\n        },\n        ownKeys(target) {\n            return target.columns;\n        },\n        getOwnPropertyDescriptor(target, prop) {\n            return {\n                configurable: true,\n                enumerable: true,\n                value: target.getColumn(prop),\n            };\n        },\n    });\n}",
  "_LazyDataFrame": "(_ldf) => {\n    const unwrap = (method, ...args) => {\n        return _ldf[method](...args);\n    };\n    const wrap = (method, ...args) => {\n        return (0, exports._LazyDataFrame)(unwrap(method, ...args));\n    };\n    return {\n        _ldf,\n        [inspect]() {\n            return _ldf.describeOptimizedPlan();\n        },\n        get [Symbol.toStringTag]() {\n            return \"LazyDataFrame\";\n        },\n        get columns() {\n            return _ldf.columns;\n        },\n        describePlan() {\n            return _ldf.describePlan();\n        },\n        describeOptimizedPlan() {\n            return _ldf.describeOptimizedPlan();\n        },\n        cache() {\n            return (0, exports._LazyDataFrame)(_ldf.cache());\n        },\n        clone() {\n            return (0, exports._LazyDataFrame)(_ldf.clone());\n        },\n        collectSync() {\n            return (0, dataframe_1._DataFrame)(_ldf.collectSync());\n        },\n        collect(opts) {\n            if (opts?.noOptimization) {\n                opts.predicatePushdown = false;\n                opts.projectionPushdown = false;\n                opts.slicePushdown = false;\n                opts.commSubplanElim = false;\n                opts.commSubexprElim = false;\n            }\n            if (opts?.streaming)\n                opts.commSubplanElim = false;\n            if (opts) {\n                _ldf = _ldf.optimizationToggle(opts.typeCoercion, opts.predicatePushdown, opts.projectionPushdown, opts.simplifyExpression, opts.slicePushdown, opts.commSubplanElim, opts.commSubexprElim, opts.streaming);\n            }\n            return _ldf.collect().then(dataframe_1._DataFrame);\n        },\n        drop(...cols) {\n            return (0, exports._LazyDataFrame)(_ldf.dropColumns(cols.flat(2)));\n        },\n        distinct(...args) {\n            return (0, exports._LazyDataFrame)(_ldf.unique(...args));\n        },\n        unique(opts = false, subset, keep = \"first\") {\n            const defaultOptions = {\n                maintainOrder: false,\n                keep: \"first\",\n            };\n            if (typeof opts === \"boolean\") {\n                const o = { ...defaultOptions, maintainOrder: opts, subset, keep };\n                return (0, exports._LazyDataFrame)(_ldf.unique(o.maintainOrder, o?.subset?.flat(2), o.keep));\n            }\n            if (opts.subset) {\n                opts.subset = [opts.subset].flat(3);\n            }\n            const o = { ...defaultOptions, ...opts };\n            return (0, exports._LazyDataFrame)(_ldf.unique(o.maintainOrder, o.subset, o.keep));\n        },\n        dropNulls(...subset) {\n            if (subset.length) {\n                return wrap(\"dropNulls\", subset.flat(2));\n            }\n            return wrap(\"dropNulls\");\n        },\n        explode(...columns) {\n            if (!columns.length) {\n                const cols = (0, utils_1.selectionToExprList)(_ldf.columns, false);\n                return wrap(\"explode\", cols);\n            }\n            const column = (0, utils_1.selectionToExprList)(columns, false);\n            return wrap(\"explode\", column);\n        },\n        fetchSync(numRows, opts) {\n            if (opts?.noOptimization) {\n                opts.predicatePushdown = false;\n                opts.projectionPushdown = false;\n                opts.slicePushdown = false;\n                opts.commSubplanElim = false;\n                opts.commSubexprElim = false;\n            }\n            if (opts?.streaming)\n                opts.commSubplanElim = false;\n            if (opts) {\n                _ldf = _ldf.optimizationToggle(opts.typeCoercion, opts.predicatePushdown, opts.projectionPushdown, opts.simplifyExpr, opts.slicePushdown, opts.commSubplanElim, opts.commSubexprElim, opts.streaming);\n            }\n            return (0, dataframe_1._DataFrame)(_ldf.fetchSync(numRows));\n        },\n        fetch(numRows, opts) {\n            if (opts?.noOptimization) {\n                opts.predicatePushdown = false;\n                opts.projectionPushdown = false;\n                opts.slicePushdown = false;\n                opts.commSubplanElim = false;\n                opts.commSubexprElim = false;\n            }\n            if (opts?.streaming)\n                opts.commSubplanElim = false;\n            if (opts) {\n                _ldf = _ldf.optimizationToggle(opts.typeCoercion, opts.predicatePushdown, opts.projectionPushdown, opts.simplifyExpr, opts.slicePushdown, opts.commSubplanElim, opts.commSubexprElim, opts.streaming);\n            }\n            return _ldf.fetch(numRows).then(dataframe_1._DataFrame);\n        },\n        first() {\n            return this.fetchSync(1);\n        },\n        fillNull(exprOrValue) {\n            const fillValue = (0, expr_1.exprToLitOrExpr)(exprOrValue)._expr;\n            return (0, exports._LazyDataFrame)(_ldf.fillNull(fillValue));\n        },\n        filter(exprOrValue) {\n            const predicate = (0, expr_1.exprToLitOrExpr)(exprOrValue, false)._expr;\n            return (0, exports._LazyDataFrame)(_ldf.filter(predicate));\n        },\n        groupBy(opt, maintainOrder = true) {\n            if (opt?.by !== undefined) {\n                const by = (0, utils_1.selectionToExprList)([opt.by], false);\n                return (0, groupby_1._LazyGroupBy)(_ldf.groupby(by, opt.maintainOrder));\n            }\n            const by = (0, utils_1.selectionToExprList)([opt], false);\n            return (0, groupby_1._LazyGroupBy)(_ldf.groupby(by, maintainOrder));\n        },\n        groupByRolling({ indexColumn, by, period, offset, closed, check_sorted }) {\n            offset = offset ?? `-${period}`;\n            closed = closed ?? \"right\";\n            by = prepareGroupbyInputs(by);\n            check_sorted = check_sorted ?? false;\n            const lgb = _ldf.groupbyRolling(polars_internal_1.default.col(indexColumn), period, offset, closed, by, check_sorted);\n            return (0, groupby_1._LazyGroupBy)(lgb);\n        },\n        groupByDynamic({ indexColumn, every, period, offset, includeBoundaries, closed, by, start_by, check_sorted, }) {\n            period = period ?? every;\n            offset = offset ?? `-${period}`;\n            closed = closed ?? \"right\";\n            by = prepareGroupbyInputs(by);\n            includeBoundaries = includeBoundaries ?? false;\n            start_by = start_by ?? \"monday\";\n            check_sorted = check_sorted ?? false;\n            const lgb = _ldf.groupbyDynamic(polars_internal_1.default.col(indexColumn), every, period, offset, includeBoundaries, closed, by, start_by, check_sorted);\n            return (0, groupby_1._LazyGroupBy)(lgb);\n        },\n        head(len = 5) {\n            return (0, exports._LazyDataFrame)(_ldf.slice(0, len));\n        },\n        inner() {\n            return _ldf;\n        },\n        join(df, options) {\n            options = {\n                how: \"inner\",\n                suffix: \"right\",\n                allowParallel: true,\n                forceParallel: false,\n                ...options,\n            };\n            const { how, suffix, allowParallel, forceParallel } = options;\n            if (how === \"cross\") {\n                return (0, exports._LazyDataFrame)(_ldf.join(df._ldf, [], [], allowParallel, forceParallel, how, suffix, [], []));\n            }\n            let leftOn;\n            let rightOn;\n            if (options.on) {\n                const on = (0, utils_1.selectionToExprList)(options.on, false);\n                leftOn = on;\n                rightOn = on;\n            }\n            else if ((options.leftOn && !options.rightOn) ||\n                (options.rightOn && !options.leftOn)) {\n                throw new TypeError(\"You should pass the column to join on as an argument.\");\n            }\n            else {\n                leftOn = (0, utils_1.selectionToExprList)(options.leftOn, false);\n                rightOn = (0, utils_1.selectionToExprList)(options.rightOn, false);\n            }\n            const ldf = _ldf.join(df._ldf, leftOn, rightOn, allowParallel, forceParallel, how, suffix, [], []);\n            return (0, exports._LazyDataFrame)(ldf);\n        },\n        joinAsof(other, options) {\n            options = {\n                suffix: \"_right\",\n                allowParallel: true,\n                forceParallel: false,\n                strategy: \"backward\",\n                ...options,\n            };\n            const { suffix, strategy, allowParallel, forceParallel } = options;\n            let leftOn;\n            let rightOn;\n            if (!other?._ldf) {\n                throw new TypeError(\"Expected a 'lazyFrame' as join table\");\n            }\n            if (options.on) {\n                leftOn = rightOn = options.on;\n            }\n            else if ((options.leftOn && !options.rightOn) ||\n                (options.rightOn && !options.leftOn)) {\n                throw new TypeError(\"You should pass the column to join on as an argument.\");\n            }\n            else {\n                leftOn = options.leftOn;\n                rightOn = options.rightOn;\n            }\n            let byLeft;\n            if (typeof options.byLeft === \"string\") {\n                byLeft = [options.byLeft];\n            }\n            else if (Array.isArray(options.byLeft)) {\n                byLeft = options.byLeft;\n            }\n            let byRight;\n            if (typeof options.byRight === \"string\") {\n                byRight = [options.byRight];\n            }\n            else if (Array.isArray(options.byRight)) {\n                byRight = options.byRight;\n            }\n            if (typeof options.by === \"string\") {\n                byLeft = byRight = [options.by];\n            }\n            else if (Array.isArray(options.by)) {\n                byLeft = byRight = options.by;\n            }\n            let toleranceStr;\n            let toleranceNum;\n            if (typeof options.tolerance === \"string\") {\n                toleranceStr = options.tolerance;\n            }\n            else {\n                toleranceNum = options.tolerance;\n            }\n            const ldf = _ldf.joinAsof(other._ldf, polars_internal_1.default.col(leftOn), polars_internal_1.default.col(rightOn), byLeft, byRight, allowParallel, forceParallel, suffix, strategy, toleranceNum, toleranceStr);\n            return (0, exports._LazyDataFrame)(ldf);\n        },\n        last() {\n            return (0, exports._LazyDataFrame)(_ldf.tail(1));\n        },\n        limit(len = 5) {\n            return (0, exports._LazyDataFrame)(_ldf.slice(0, len));\n        },\n        max() {\n            return (0, exports._LazyDataFrame)(_ldf.max());\n        },\n        mean() {\n            return (0, exports._LazyDataFrame)(_ldf.mean());\n        },\n        median() {\n            return (0, exports._LazyDataFrame)(_ldf.median());\n        },\n        melt(ids, values) {\n            return (0, exports._LazyDataFrame)(_ldf.unpivot((0, utils_1.columnOrColumnsStrict)(ids), (0, utils_1.columnOrColumnsStrict)(values)));\n        },\n        unpivot(ids, values) {\n            return (0, exports._LazyDataFrame)(_ldf.unpivot((0, utils_1.columnOrColumnsStrict)(ids), (0, utils_1.columnOrColumnsStrict)(values)));\n        },\n        min() {\n            return (0, exports._LazyDataFrame)(_ldf.min());\n        },\n        quantile(quantile, interpolation = \"nearest\") {\n            return (0, exports._LazyDataFrame)(_ldf.quantile(quantile, interpolation));\n        },\n        rename(mapping) {\n            const existing = Object.keys(mapping);\n            const replacements = Object.values(mapping);\n            return (0, exports._LazyDataFrame)(_ldf.rename(existing, replacements));\n        },\n        reverse() {\n            return (0, exports._LazyDataFrame)(_ldf.reverse());\n        },\n        select(...exprs) {\n            const selections = (0, utils_1.selectionToExprList)(exprs, false);\n            return (0, exports._LazyDataFrame)(_ldf.select(selections));\n        },\n        shift(periods) {\n            return (0, exports._LazyDataFrame)(_ldf.shift(periods));\n        },\n        shiftAndFill(opts, fillValue) {\n            if (typeof opts === \"number\") {\n                return (0, exports._LazyDataFrame)(_ldf.shiftAndFill(opts, fillValue));\n            }\n            return (0, exports._LazyDataFrame)(_ldf.shiftAndFill(opts?.n, opts?.fillValue));\n        },\n        slice(opt, len) {\n            if (opt?.offset !== undefined) {\n                return (0, exports._LazyDataFrame)(_ldf.slice(opt.offset, opt.length));\n            }\n            return (0, exports._LazyDataFrame)(_ldf.slice(opt, len));\n        },\n        sort(arg, descending = false, nulls_last = false, maintain_order = false) {\n            if (arg?.by !== undefined) {\n                return this.sort(arg.by, arg.descending, arg.nulls_last, arg.maintain_order);\n            }\n            if (typeof arg === \"string\") {\n                return wrap(\"sort\", arg, descending, nulls_last, maintain_order);\n            }\n            const by = (0, utils_1.selectionToExprList)(arg, false);\n            return wrap(\"sortByExprs\", by, descending, nulls_last, maintain_order);\n        },\n        std() {\n            return (0, exports._LazyDataFrame)(_ldf.std());\n        },\n        sum() {\n            return (0, exports._LazyDataFrame)(_ldf.sum());\n        },\n        var() {\n            return (0, exports._LazyDataFrame)(_ldf.var());\n        },\n        tail(length = 5) {\n            return (0, exports._LazyDataFrame)(_ldf.tail(length));\n        },\n        toJSON(...args) {\n            // this is passed by `JSON.stringify` when calling `toJSON()`\n            if (args[0] === \"\") {\n                return JSON.parse(_ldf.serialize(\"json\").toString());\n            }\n            return _ldf.serialize(\"json\").toString();\n        },\n        serialize(format) {\n            return _ldf.serialize(format);\n        },\n        withColumn(expr) {\n            return (0, exports._LazyDataFrame)(_ldf.withColumn(expr._expr));\n        },\n        withColumns(...columns) {\n            const exprs = (0, utils_1.selectionToExprList)(columns, false);\n            return (0, exports._LazyDataFrame)(_ldf.withColumns(exprs));\n        },\n        withColumnRenamed(existing, replacement) {\n            return (0, exports._LazyDataFrame)(_ldf.rename([existing], [replacement]));\n        },\n        withRowCount(name = \"row_nr\") {\n            return (0, exports._LazyDataFrame)(_ldf.withRowCount(name));\n        },\n        sinkCSV(path, options = {}) {\n            options.maintainOrder = options.maintainOrder ?? false;\n            _ldf.sinkCsv(path, options);\n        },\n        sinkParquet(path, options = {}) {\n            options.compression = options.compression ?? \"zstd\";\n            options.statistics = options.statistics ?? false;\n            _ldf.sinkParquet(path, options);\n        },\n    };\n}",
  "nth": "function nth(n) {\n    return (0, expr_1._Expr)(polars_internal_1.default.nth(n));\n}",
  "all": "function all() {\n    return col(\"*\");\n}",
  "len": "function len() {\n    return (0, expr_1._Expr)(polars_internal_1.default.len());\n}",
  "_LazyGroupBy": "(_lgb) => {\n    return {\n        agg(...aggs) {\n            aggs = (0, utils_1.selectionToExprList)(aggs, false);\n            const ret = _lgb.agg(aggs.flat());\n            return (0, dataframe_1._LazyDataFrame)(ret);\n        },\n        head(n = 5) {\n            return (0, dataframe_1._LazyDataFrame)(_lgb.head(n));\n        },\n        tail(n = 5) {\n            return (0, dataframe_1._LazyDataFrame)(_lgb.tail(n));\n        },\n    };\n}",
  "_Expr": "(_expr) => {\n    const unwrap = (method, ...args) => {\n        return _expr[method](...args);\n    };\n    const wrap = (method, ...args) => {\n        return (0, exports._Expr)(unwrap(method, ...args));\n    };\n    const wrapExprArg = (method, lit = false) => (other) => {\n        const expr = (0, exports.exprToLitOrExpr)(other, lit).inner();\n        return wrap(method, expr);\n    };\n    const rolling = (method) => (opts, weights, minPeriods, center) => {\n        const windowSize = opts?.[\"windowSize\"] ?? (typeof opts === \"number\" ? opts : null);\n        if (windowSize === null) {\n            throw new Error(\"window size is required\");\n        }\n        const callOpts = {\n            windowSize: windowSize,\n            weights: opts?.[\"weights\"] ?? weights,\n            minPeriods: opts?.[\"minPeriods\"] ?? minPeriods ?? windowSize,\n            center: opts?.[\"center\"] ?? center ?? false,\n        };\n        return wrap(method, callOpts);\n    };\n    return {\n        _expr,\n        [Symbol.toStringTag]() {\n            return \"Expr\";\n        },\n        [utils_1.INSPECT_SYMBOL]() {\n            return _expr.toString();\n        },\n        serialize(format) {\n            return _expr.serialize(format);\n        },\n        toString() {\n            return _expr.toString();\n        },\n        toJSON(...args) {\n            // this is passed by `JSON.stringify` when calling `toJSON()`\n            if (args[0] === \"\") {\n                return _expr.toJs();\n            }\n            return _expr.serialize(\"json\").toString();\n        },\n        get str() {\n            return str.ExprStringFunctions(_expr);\n        },\n        get lst() {\n            return lst.ExprListFunctions(_expr);\n        },\n        get date() {\n            return dt.ExprDateTimeFunctions(_expr);\n        },\n        get struct() {\n            return struct.ExprStructFunctions(_expr);\n        },\n        abs() {\n            return (0, exports._Expr)(_expr.abs());\n        },\n        aggGroups() {\n            return (0, exports._Expr)(_expr.aggGroups());\n        },\n        alias(name) {\n            return (0, exports._Expr)(_expr.alias(name));\n        },\n        inner() {\n            return _expr;\n        },\n        and(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other, false).inner();\n            return (0, exports._Expr)(_expr.and(expr));\n        },\n        arccos() {\n            return (0, exports._Expr)(_expr.arccos());\n        },\n        arccosh() {\n            return (0, exports._Expr)(_expr.arccosh());\n        },\n        arcsin() {\n            return (0, exports._Expr)(_expr.arcsin());\n        },\n        arcsinh() {\n            return (0, exports._Expr)(_expr.arcsinh());\n        },\n        arctan() {\n            return (0, exports._Expr)(_expr.arctan());\n        },\n        arctanh() {\n            return (0, exports._Expr)(_expr.arctanh());\n        },\n        argMax() {\n            return (0, exports._Expr)(_expr.argMax());\n        },\n        argMin() {\n            return (0, exports._Expr)(_expr.argMin());\n        },\n        argSort(reverse = false, maintain_order) {\n            reverse = reverse?.reverse ?? reverse;\n            maintain_order = reverse?.maintain_order ?? maintain_order;\n            return (0, exports._Expr)(_expr.argSort(reverse, false, false, maintain_order));\n        },\n        argUnique() {\n            return (0, exports._Expr)(_expr.argUnique());\n        },\n        as(name) {\n            return (0, exports._Expr)(_expr.alias(name));\n        },\n        backwardFill() {\n            return (0, exports._Expr)(_expr.backwardFill());\n        },\n        cast(dtype, strict = false) {\n            return (0, exports._Expr)(_expr.cast(dtype, strict));\n        },\n        ceil() {\n            return (0, exports._Expr)(_expr.ceil());\n        },\n        clip(arg, max) {\n            if (typeof arg === \"number\") {\n                return (0, exports._Expr)(_expr.clip((0, exports.exprToLitOrExpr)(arg)._expr, (0, exports.exprToLitOrExpr)(max)._expr));\n            }\n            return (0, exports._Expr)(_expr.clip((0, exports.exprToLitOrExpr)(arg.min)._expr, (0, exports.exprToLitOrExpr)(arg.max)._expr));\n        },\n        cos() {\n            return (0, exports._Expr)(_expr.cos());\n        },\n        cosh() {\n            return (0, exports._Expr)(_expr.cosh());\n        },\n        cot() {\n            return (0, exports._Expr)(_expr.cot());\n        },\n        count() {\n            return (0, exports._Expr)(_expr.count());\n        },\n        cumCount(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumCount(reverse?.reverse ?? reverse));\n        },\n        cumMax(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumMax(reverse));\n        },\n        cumMin(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumMin(reverse));\n        },\n        cumProd(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumProd(reverse));\n        },\n        cumSum(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumSum(reverse));\n        },\n        diff(n, nullBehavior = \"ignore\") {\n            if (typeof n === \"number\") {\n                return (0, exports._Expr)(_expr.diff(n, nullBehavior));\n            }\n            return (0, exports._Expr)(_expr.diff(n.n, n.nullBehavior));\n        },\n        dot(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other, false).inner();\n            return (0, exports._Expr)(_expr.dot(expr));\n        },\n        ewmMean(opts, adjust, minPeriods, bias, ignoreNulls) {\n            if (opts) {\n                if (typeof opts === \"number\") {\n                    return wrap(\"ewmMean\", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);\n                }\n                return wrap(\"ewmMean\", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);\n            }\n            return wrap(\"ewmMean\", 0.5, true, 1, false, true);\n        },\n        ewmStd(opts, adjust, minPeriods, bias, ignoreNulls) {\n            if (opts) {\n                if (typeof opts === \"number\") {\n                    return wrap(\"ewmStd\", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);\n                }\n                return wrap(\"ewmStd\", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);\n            }\n            return wrap(\"ewmStd\", 0.5, true, 1, false, true);\n        },\n        ewmVar(opts, adjust, minPeriods, bias, ignoreNulls) {\n            if (opts) {\n                if (typeof opts === \"number\") {\n                    return wrap(\"ewmVar\", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);\n                }\n                return wrap(\"ewmVar\", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);\n            }\n            return wrap(\"ewmVar\", 0.5, true, 1, false, true);\n        },\n        exclude(...columns) {\n            return (0, exports._Expr)(_expr.exclude(columns.flat(2)));\n        },\n        explode() {\n            return (0, exports._Expr)(_expr.explode());\n        },\n        exp() {\n            return (0, exports._Expr)(_expr.exp());\n        },\n        extend(o, n) {\n            if (n !== null && typeof n === \"number\") {\n                return (0, exports._Expr)(_expr.extendConstant(o, n));\n            }\n            return (0, exports._Expr)(_expr.extendConstant(o.value, o.n));\n        },\n        extendConstant(o, n) {\n            if (n !== null && typeof n === \"number\") {\n                return (0, exports._Expr)(_expr.extendConstant(o, n));\n            }\n            return (0, exports._Expr)(_expr.extendConstant(o.value, o.n));\n        },\n        fillNan(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other, true).inner();\n            return (0, exports._Expr)(_expr.fillNan(expr));\n        },\n        fillNull(fillValue) {\n            if ([\"backward\", \"forward\", \"mean\", \"min\", \"max\", \"zero\", \"one\"].includes(fillValue)) {\n                return (0, exports._Expr)(_expr.fillNullWithStrategy(fillValue));\n            }\n            const expr = (0, exports.exprToLitOrExpr)(fillValue).inner();\n            return (0, exports._Expr)(_expr.fillNull(expr));\n        },\n        filter(predicate) {\n            const expr = (0, exports.exprToLitOrExpr)(predicate).inner();\n            return (0, exports._Expr)(_expr.filter(expr));\n        },\n        first() {\n            return (0, exports._Expr)(_expr.first());\n        },\n        flatten() {\n            return (0, exports._Expr)(_expr.explode());\n        },\n        floor() {\n            return (0, exports._Expr)(_expr.floor());\n        },\n        forwardFill() {\n            return (0, exports._Expr)(_expr.forwardFill());\n        },\n        gather(indices) {\n            if (Array.isArray(indices)) {\n                indices = polars_internal_1.default.lit((0, series_1.Series)(indices).inner());\n            }\n            else {\n                indices = indices.inner();\n            }\n            return wrap(\"gather\", indices);\n        },\n        gatherEvery(n, offset = 0) {\n            return (0, exports._Expr)(_expr.gatherEvery(n, offset));\n        },\n        hash(obj = 0, k1 = 1, k2 = 2, k3 = 3) {\n            if (typeof obj === \"number\" || typeof obj === \"bigint\") {\n                return wrap(\"hash\", BigInt(obj), BigInt(k1), BigInt(k2), BigInt(k3));\n            }\n            const o = { k0: obj, k1: k1, k2: k2, k3: k3, ...obj };\n            return wrap(\"hash\", BigInt(o.k0), BigInt(o.k1), BigInt(o.k2), BigInt(o.k3));\n        },\n        head(length) {\n            if (typeof length === \"number\") {\n                return wrap(\"head\", length);\n            }\n            return wrap(\"head\", length.length);\n        },\n        interpolate(method = \"linear\") {\n            return (0, exports._Expr)(_expr.interpolate(method));\n        },\n        isDuplicated() {\n            return (0, exports._Expr)(_expr.isDuplicated());\n        },\n        isFinite() {\n            return (0, exports._Expr)(_expr.isFinite());\n        },\n        isInfinite() {\n            return (0, exports._Expr)(_expr.isInfinite());\n        },\n        isFirstDistinct() {\n            return (0, exports._Expr)(_expr.isFirstDistinct());\n        },\n        isNan() {\n            return (0, exports._Expr)(_expr.isNan());\n        },\n        isNotNan() {\n            return (0, exports._Expr)(_expr.isNotNan());\n        },\n        isNotNull() {\n            return (0, exports._Expr)(_expr.isNotNull());\n        },\n        isNull() {\n            return (0, exports._Expr)(_expr.isNull());\n        },\n        isUnique() {\n            return (0, exports._Expr)(_expr.isUnique());\n        },\n        isIn(other) {\n            if (Array.isArray(other)) {\n                other = polars_internal_1.default.lit((0, series_1.Series)(other).inner());\n            }\n            else {\n                other = (0, exports.exprToLitOrExpr)(other, false).inner();\n            }\n            return wrap(\"isIn\", other);\n        },\n        keepName() {\n            return (0, exports._Expr)(_expr.keepName());\n        },\n        kurtosis(obj, bias = true) {\n            const fisher = obj?.[\"fisher\"] ?? (typeof obj === \"boolean\" ? obj : true);\n            bias = obj?.[\"bias\"] ?? bias;\n            return (0, exports._Expr)(_expr.kurtosis(fisher, bias));\n        },\n        last() {\n            return (0, exports._Expr)(_expr.last());\n        },\n        list() {\n            return (0, exports._Expr)(_expr.list());\n        },\n        log1p() {\n            console.log(_expr.log1p);\n            return (0, exports._Expr)(_expr.log1p());\n        },\n        log(base) {\n            return (0, exports._Expr)(_expr.log(base ?? Math.E));\n        },\n        lowerBound() {\n            return (0, exports._Expr)(_expr.lowerBound());\n        },\n        peakMax() {\n            return (0, exports._Expr)(_expr.peakMax());\n        },\n        peakMin() {\n            return (0, exports._Expr)(_expr.peakMin());\n        },\n        max() {\n            return (0, exports._Expr)(_expr.max());\n        },\n        mean() {\n            return (0, exports._Expr)(_expr.mean());\n        },\n        median() {\n            return (0, exports._Expr)(_expr.median());\n        },\n        min() {\n            return (0, exports._Expr)(_expr.min());\n        },\n        mode() {\n            return (0, exports._Expr)(_expr.mode());\n        },\n        not() {\n            return (0, exports._Expr)(_expr.not());\n        },\n        nUnique() {\n            return (0, exports._Expr)(_expr.nUnique());\n        },\n        or(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other).inner();\n            return (0, exports._Expr)(_expr.or(expr));\n        },\n        over(...exprs) {\n            const partitionBy = (0, utils_1.selectionToExprList)(exprs, false);\n            return wrap(\"over\", partitionBy);\n        },\n        pow(exponent) {\n            return (0, exports._Expr)(_expr.pow(exponent?.exponent ?? exponent));\n        },\n        prefix(prefix) {\n            return (0, exports._Expr)(_expr.prefix(prefix));\n        },\n        quantile(quantile, interpolation = \"nearest\") {\n            if (exports.Expr.isExpr(quantile)) {\n                quantile = quantile._expr;\n            }\n            else {\n                quantile = polars_internal_1.default.lit(quantile);\n            }\n            return (0, exports._Expr)(_expr.quantile(quantile, interpolation));\n        },\n        rank(method = \"average\", reverse = false) {\n            return (0, exports._Expr)(_expr.rank(method?.method ?? method, method?.reverse ?? reverse));\n        },\n        reinterpret(signed = true) {\n            signed = signed?.signed ?? signed;\n            return (0, exports._Expr)(_expr.reinterpret(signed));\n        },\n        repeatBy(expr) {\n            const e = (0, exports.exprToLitOrExpr)(expr, false)._expr;\n            return (0, exports._Expr)(_expr.repeatBy(e));\n        },\n        replace(old, newValue) {\n            let oldIn = old;\n            let newIn = newValue;\n            if (old && typeof old === \"object\" && !Array.isArray(old)) {\n                oldIn = Object.keys(old[\"old\"]);\n                newIn = Object.values(old[\"old\"]);\n            }\n            return (0, exports._Expr)(_expr.replace((0, exports.exprToLitOrExpr)(oldIn)._expr, (0, exports.exprToLitOrExpr)(newIn)._expr));\n        },\n        replaceStrict(old, newValue, defaultValue, returnDtype) {\n            let oldIn = old;\n            let newIn = newValue;\n            let defIn = defaultValue;\n            if (old && typeof old === \"object\" && !Array.isArray(old)) {\n                oldIn = Object.keys(old[\"old\"]);\n                newIn = Object.values(old[\"old\"]);\n                defIn = old[\"default_\"];\n            }\n            return (0, exports._Expr)(_expr.replaceStrict((0, exports.exprToLitOrExpr)(oldIn)._expr, (0, exports.exprToLitOrExpr)(newIn)._expr, defIn ? (0, exports.exprToLitOrExpr)(defIn)._expr : undefined, returnDtype));\n        },\n        reverse() {\n            return (0, exports._Expr)(_expr.reverse());\n        },\n        rollingMax: rolling(\"rollingMax\"),\n        rollingMean: rolling(\"rollingMean\"),\n        rollingMin: rolling(\"rollingMin\"),\n        rollingSum: rolling(\"rollingSum\"),\n        rollingStd: rolling(\"rollingStd\"),\n        rollingVar: rolling(\"rollingVar\"),\n        rollingMedian: rolling(\"rollingMedian\"),\n        rollingQuantile(val, interpolation, windowSize, weights, minPeriods, center, by, closedWindow, warnIfUnsorted) {\n            if (typeof val === \"number\") {\n                return wrap(\"rollingQuantile\", {\n                    windowSize: `${windowSize}i`,\n                    weights,\n                    minPeriods,\n                    center,\n                });\n            }\n            windowSize =\n                val?.[\"windowSize\"] ?? (typeof val === \"number\" ? val : null);\n            if (windowSize === null) {\n                throw new Error(\"window size is required\");\n            }\n            return wrap(\"rollingQuantile\", val.quantile, val.interpolation ?? \"nearest\", windowSize, val?.[\"weights\"] ?? weights ?? null, val?.[\"minPeriods\"] ?? minPeriods ?? windowSize, val?.[\"center\"] ?? center ?? false, val?.[\"by\"] ?? by, closedWindow, val?.[\"warnIfUnsorted\"] ?? warnIfUnsorted ?? true);\n        },\n        rollingSkew(val, bias = true) {\n            if (typeof val === \"number\") {\n                return wrap(\"rollingSkew\", val, bias);\n            }\n            return wrap(\"rollingSkew\", val.windowSize, val.bias ?? bias);\n        },\n        round(decimals) {\n            return (0, exports._Expr)(_expr.round(decimals?.decimals ?? decimals));\n        },\n        sample(opts, frac, withReplacement = false, seed) {\n            if (opts?.n !== undefined || opts?.frac !== undefined) {\n                return this.sample(opts.n, opts.frac, opts.withReplacement, seed);\n            }\n            if (typeof opts === \"number\") {\n                throw new Error(\"sample_n is not yet supported for expr\");\n            }\n            if (typeof frac === \"number\") {\n                return wrap(\"sampleFrac\", frac, withReplacement, false, seed);\n            }\n            throw new TypeError(\"must specify either 'frac' or 'n'\");\n        },\n        shift(periods) {\n            return (0, exports._Expr)(_expr.shift((0, exports.exprToLitOrExpr)(periods)._expr));\n        },\n        shiftAndFill(optOrPeriods, fillValue) {\n            if (typeof optOrPeriods === \"number\") {\n                return wrap(\"shiftAndFill\", optOrPeriods, fillValue);\n            }\n            return wrap(\"shiftAndFill\", optOrPeriods.periods, optOrPeriods.fillValue);\n        },\n        skew(bias) {\n            return wrap(\"skew\", bias?.bias ?? bias ?? true);\n        },\n        sin() {\n            return (0, exports._Expr)(_expr.sin());\n        },\n        sinh() {\n            return (0, exports._Expr)(_expr.sinh());\n        },\n        slice(arg, len) {\n            if (typeof arg === \"number\") {\n                return wrap(\"slice\", polars_internal_1.default.lit(arg), polars_internal_1.default.lit(len));\n            }\n            return wrap(\"slice\", polars_internal_1.default.lit(arg.offset), polars_internal_1.default.lit(arg.length));\n        },\n        sort(reverse = false, nullsLast = false, maintain_order = false) {\n            if (typeof reverse === \"boolean\") {\n                return wrap(\"sortWith\", reverse, nullsLast, false, maintain_order);\n            }\n            return wrap(\"sortWith\", reverse?.reverse ?? false, reverse?.nullsLast ?? nullsLast, false, reverse?.maintain_order ?? maintain_order);\n        },\n        sortBy(arg, reverse = false) {\n            if (arg?.by !== undefined) {\n                return this.sortBy(arg.by, arg.reverse);\n            }\n            reverse = Array.isArray(reverse) ? reverse.flat() : [reverse];\n            const by = (0, utils_1.selectionToExprList)(arg, false);\n            return wrap(\"sortBy\", by, reverse);\n        },\n        std() {\n            return (0, exports._Expr)(_expr.std());\n        },\n        suffix(suffix) {\n            return (0, exports._Expr)(_expr.suffix(suffix));\n        },\n        sum() {\n            return (0, exports._Expr)(_expr.sum());\n        },\n        tail(length) {\n            return (0, exports._Expr)(_expr.tail(length));\n        },\n        tan() {\n            return (0, exports._Expr)(_expr.tan());\n        },\n        tanh() {\n            return (0, exports._Expr)(_expr.tanh());\n        },\n        unique(opt) {\n            if (opt || opt?.maintainOrder) {\n                return wrap(\"uniqueStable\");\n            }\n            return wrap(\"unique\");\n        },\n        upperBound() {\n            return (0, exports._Expr)(_expr.upperBound());\n        },\n        where(expr) {\n            return this.filter(expr);\n        },\n        var() {\n            return (0, exports._Expr)(_expr.var());\n        },\n        add: wrapExprArg(\"add\"),\n        sub: wrapExprArg(\"sub\"),\n        div: wrapExprArg(\"div\"),\n        mul: wrapExprArg(\"mul\"),\n        rem: wrapExprArg(\"rem\"),\n        plus: wrapExprArg(\"add\"),\n        minus: wrapExprArg(\"sub\"),\n        divideBy: wrapExprArg(\"div\"),\n        multiplyBy: wrapExprArg(\"mul\"),\n        modulo: wrapExprArg(\"rem\"),\n        eq: wrapExprArg(\"eq\"),\n        equals: wrapExprArg(\"eq\"),\n        gtEq: wrapExprArg(\"gtEq\"),\n        greaterThanEquals: wrapExprArg(\"gtEq\"),\n        gt: wrapExprArg(\"gt\"),\n        greaterThan: wrapExprArg(\"gt\"),\n        ltEq: wrapExprArg(\"ltEq\"),\n        lessThanEquals: wrapExprArg(\"ltEq\"),\n        lt: wrapExprArg(\"lt\"),\n        lessThan: wrapExprArg(\"lt\"),\n        neq: wrapExprArg(\"neq\"),\n        notEquals: wrapExprArg(\"neq\"),\n    };\n}",
  "exprToLitOrExpr": "(expr, stringToLit = true) => {\n    if ((0, types_1.isRegExp)(expr)) {\n        return (0, exports._Expr)(polars_internal_1.default.lit((0, utils_1.regexToString)(expr)));\n    }\n    if (typeof expr === \"string\" && !stringToLit) {\n        return (0, exports._Expr)(polars_internal_1.default.col(expr));\n    }\n    if (exports.Expr.isExpr(expr)) {\n        return expr;\n    }\n    if (series_1.Series.isSeries(expr)) {\n        return (0, exports._Expr)(polars_internal_1.default.lit(expr._s));\n    }\n    return (0, exports._Expr)(polars_internal_1.default.lit(expr));\n}",
  "default": {
    "Expr": "(_expr) => {\n    const unwrap = (method, ...args) => {\n        return _expr[method](...args);\n    };\n    const wrap = (method, ...args) => {\n        return (0, exports._Expr)(unwrap(method, ...args));\n    };\n    const wrapExprArg = (method, lit = false) => (other) => {\n        const expr = (0, exports.exprToLitOrExpr)(other, lit).inner();\n        return wrap(method, expr);\n    };\n    const rolling = (method) => (opts, weights, minPeriods, center) => {\n        const windowSize = opts?.[\"windowSize\"] ?? (typeof opts === \"number\" ? opts : null);\n        if (windowSize === null) {\n            throw new Error(\"window size is required\");\n        }\n        const callOpts = {\n            windowSize: windowSize,\n            weights: opts?.[\"weights\"] ?? weights,\n            minPeriods: opts?.[\"minPeriods\"] ?? minPeriods ?? windowSize,\n            center: opts?.[\"center\"] ?? center ?? false,\n        };\n        return wrap(method, callOpts);\n    };\n    return {\n        _expr,\n        [Symbol.toStringTag]() {\n            return \"Expr\";\n        },\n        [utils_1.INSPECT_SYMBOL]() {\n            return _expr.toString();\n        },\n        serialize(format) {\n            return _expr.serialize(format);\n        },\n        toString() {\n            return _expr.toString();\n        },\n        toJSON(...args) {\n            // this is passed by `JSON.stringify` when calling `toJSON()`\n            if (args[0] === \"\") {\n                return _expr.toJs();\n            }\n            return _expr.serialize(\"json\").toString();\n        },\n        get str() {\n            return str.ExprStringFunctions(_expr);\n        },\n        get lst() {\n            return lst.ExprListFunctions(_expr);\n        },\n        get date() {\n            return dt.ExprDateTimeFunctions(_expr);\n        },\n        get struct() {\n            return struct.ExprStructFunctions(_expr);\n        },\n        abs() {\n            return (0, exports._Expr)(_expr.abs());\n        },\n        aggGroups() {\n            return (0, exports._Expr)(_expr.aggGroups());\n        },\n        alias(name) {\n            return (0, exports._Expr)(_expr.alias(name));\n        },\n        inner() {\n            return _expr;\n        },\n        and(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other, false).inner();\n            return (0, exports._Expr)(_expr.and(expr));\n        },\n        arccos() {\n            return (0, exports._Expr)(_expr.arccos());\n        },\n        arccosh() {\n            return (0, exports._Expr)(_expr.arccosh());\n        },\n        arcsin() {\n            return (0, exports._Expr)(_expr.arcsin());\n        },\n        arcsinh() {\n            return (0, exports._Expr)(_expr.arcsinh());\n        },\n        arctan() {\n            return (0, exports._Expr)(_expr.arctan());\n        },\n        arctanh() {\n            return (0, exports._Expr)(_expr.arctanh());\n        },\n        argMax() {\n            return (0, exports._Expr)(_expr.argMax());\n        },\n        argMin() {\n            return (0, exports._Expr)(_expr.argMin());\n        },\n        argSort(reverse = false, maintain_order) {\n            reverse = reverse?.reverse ?? reverse;\n            maintain_order = reverse?.maintain_order ?? maintain_order;\n            return (0, exports._Expr)(_expr.argSort(reverse, false, false, maintain_order));\n        },\n        argUnique() {\n            return (0, exports._Expr)(_expr.argUnique());\n        },\n        as(name) {\n            return (0, exports._Expr)(_expr.alias(name));\n        },\n        backwardFill() {\n            return (0, exports._Expr)(_expr.backwardFill());\n        },\n        cast(dtype, strict = false) {\n            return (0, exports._Expr)(_expr.cast(dtype, strict));\n        },\n        ceil() {\n            return (0, exports._Expr)(_expr.ceil());\n        },\n        clip(arg, max) {\n            if (typeof arg === \"number\") {\n                return (0, exports._Expr)(_expr.clip((0, exports.exprToLitOrExpr)(arg)._expr, (0, exports.exprToLitOrExpr)(max)._expr));\n            }\n            return (0, exports._Expr)(_expr.clip((0, exports.exprToLitOrExpr)(arg.min)._expr, (0, exports.exprToLitOrExpr)(arg.max)._expr));\n        },\n        cos() {\n            return (0, exports._Expr)(_expr.cos());\n        },\n        cosh() {\n            return (0, exports._Expr)(_expr.cosh());\n        },\n        cot() {\n            return (0, exports._Expr)(_expr.cot());\n        },\n        count() {\n            return (0, exports._Expr)(_expr.count());\n        },\n        cumCount(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumCount(reverse?.reverse ?? reverse));\n        },\n        cumMax(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumMax(reverse));\n        },\n        cumMin(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumMin(reverse));\n        },\n        cumProd(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumProd(reverse));\n        },\n        cumSum(reverse = false) {\n            reverse = reverse?.reverse ?? reverse;\n            return (0, exports._Expr)(_expr.cumSum(reverse));\n        },\n        diff(n, nullBehavior = \"ignore\") {\n            if (typeof n === \"number\") {\n                return (0, exports._Expr)(_expr.diff(n, nullBehavior));\n            }\n            return (0, exports._Expr)(_expr.diff(n.n, n.nullBehavior));\n        },\n        dot(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other, false).inner();\n            return (0, exports._Expr)(_expr.dot(expr));\n        },\n        ewmMean(opts, adjust, minPeriods, bias, ignoreNulls) {\n            if (opts) {\n                if (typeof opts === \"number\") {\n                    return wrap(\"ewmMean\", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);\n                }\n                return wrap(\"ewmMean\", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);\n            }\n            return wrap(\"ewmMean\", 0.5, true, 1, false, true);\n        },\n        ewmStd(opts, adjust, minPeriods, bias, ignoreNulls) {\n            if (opts) {\n                if (typeof opts === \"number\") {\n                    return wrap(\"ewmStd\", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);\n                }\n                return wrap(\"ewmStd\", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);\n            }\n            return wrap(\"ewmStd\", 0.5, true, 1, false, true);\n        },\n        ewmVar(opts, adjust, minPeriods, bias, ignoreNulls) {\n            if (opts) {\n                if (typeof opts === \"number\") {\n                    return wrap(\"ewmVar\", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);\n                }\n                return wrap(\"ewmVar\", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);\n            }\n            return wrap(\"ewmVar\", 0.5, true, 1, false, true);\n        },\n        exclude(...columns) {\n            return (0, exports._Expr)(_expr.exclude(columns.flat(2)));\n        },\n        explode() {\n            return (0, exports._Expr)(_expr.explode());\n        },\n        exp() {\n            return (0, exports._Expr)(_expr.exp());\n        },\n        extend(o, n) {\n            if (n !== null && typeof n === \"number\") {\n                return (0, exports._Expr)(_expr.extendConstant(o, n));\n            }\n            return (0, exports._Expr)(_expr.extendConstant(o.value, o.n));\n        },\n        extendConstant(o, n) {\n            if (n !== null && typeof n === \"number\") {\n                return (0, exports._Expr)(_expr.extendConstant(o, n));\n            }\n            return (0, exports._Expr)(_expr.extendConstant(o.value, o.n));\n        },\n        fillNan(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other, true).inner();\n            return (0, exports._Expr)(_expr.fillNan(expr));\n        },\n        fillNull(fillValue) {\n            if ([\"backward\", \"forward\", \"mean\", \"min\", \"max\", \"zero\", \"one\"].includes(fillValue)) {\n                return (0, exports._Expr)(_expr.fillNullWithStrategy(fillValue));\n            }\n            const expr = (0, exports.exprToLitOrExpr)(fillValue).inner();\n            return (0, exports._Expr)(_expr.fillNull(expr));\n        },\n        filter(predicate) {\n            const expr = (0, exports.exprToLitOrExpr)(predicate).inner();\n            return (0, exports._Expr)(_expr.filter(expr));\n        },\n        first() {\n            return (0, exports._Expr)(_expr.first());\n        },\n        flatten() {\n            return (0, exports._Expr)(_expr.explode());\n        },\n        floor() {\n            return (0, exports._Expr)(_expr.floor());\n        },\n        forwardFill() {\n            return (0, exports._Expr)(_expr.forwardFill());\n        },\n        gather(indices) {\n            if (Array.isArray(indices)) {\n                indices = polars_internal_1.default.lit((0, series_1.Series)(indices).inner());\n            }\n            else {\n                indices = indices.inner();\n            }\n            return wrap(\"gather\", indices);\n        },\n        gatherEvery(n, offset = 0) {\n            return (0, exports._Expr)(_expr.gatherEvery(n, offset));\n        },\n        hash(obj = 0, k1 = 1, k2 = 2, k3 = 3) {\n            if (typeof obj === \"number\" || typeof obj === \"bigint\") {\n                return wrap(\"hash\", BigInt(obj), BigInt(k1), BigInt(k2), BigInt(k3));\n            }\n            const o = { k0: obj, k1: k1, k2: k2, k3: k3, ...obj };\n            return wrap(\"hash\", BigInt(o.k0), BigInt(o.k1), BigInt(o.k2), BigInt(o.k3));\n        },\n        head(length) {\n            if (typeof length === \"number\") {\n                return wrap(\"head\", length);\n            }\n            return wrap(\"head\", length.length);\n        },\n        interpolate(method = \"linear\") {\n            return (0, exports._Expr)(_expr.interpolate(method));\n        },\n        isDuplicated() {\n            return (0, exports._Expr)(_expr.isDuplicated());\n        },\n        isFinite() {\n            return (0, exports._Expr)(_expr.isFinite());\n        },\n        isInfinite() {\n            return (0, exports._Expr)(_expr.isInfinite());\n        },\n        isFirstDistinct() {\n            return (0, exports._Expr)(_expr.isFirstDistinct());\n        },\n        isNan() {\n            return (0, exports._Expr)(_expr.isNan());\n        },\n        isNotNan() {\n            return (0, exports._Expr)(_expr.isNotNan());\n        },\n        isNotNull() {\n            return (0, exports._Expr)(_expr.isNotNull());\n        },\n        isNull() {\n            return (0, exports._Expr)(_expr.isNull());\n        },\n        isUnique() {\n            return (0, exports._Expr)(_expr.isUnique());\n        },\n        isIn(other) {\n            if (Array.isArray(other)) {\n                other = polars_internal_1.default.lit((0, series_1.Series)(other).inner());\n            }\n            else {\n                other = (0, exports.exprToLitOrExpr)(other, false).inner();\n            }\n            return wrap(\"isIn\", other);\n        },\n        keepName() {\n            return (0, exports._Expr)(_expr.keepName());\n        },\n        kurtosis(obj, bias = true) {\n            const fisher = obj?.[\"fisher\"] ?? (typeof obj === \"boolean\" ? obj : true);\n            bias = obj?.[\"bias\"] ?? bias;\n            return (0, exports._Expr)(_expr.kurtosis(fisher, bias));\n        },\n        last() {\n            return (0, exports._Expr)(_expr.last());\n        },\n        list() {\n            return (0, exports._Expr)(_expr.list());\n        },\n        log1p() {\n            console.log(_expr.log1p);\n            return (0, exports._Expr)(_expr.log1p());\n        },\n        log(base) {\n            return (0, exports._Expr)(_expr.log(base ?? Math.E));\n        },\n        lowerBound() {\n            return (0, exports._Expr)(_expr.lowerBound());\n        },\n        peakMax() {\n            return (0, exports._Expr)(_expr.peakMax());\n        },\n        peakMin() {\n            return (0, exports._Expr)(_expr.peakMin());\n        },\n        max() {\n            return (0, exports._Expr)(_expr.max());\n        },\n        mean() {\n            return (0, exports._Expr)(_expr.mean());\n        },\n        median() {\n            return (0, exports._Expr)(_expr.median());\n        },\n        min() {\n            return (0, exports._Expr)(_expr.min());\n        },\n        mode() {\n            return (0, exports._Expr)(_expr.mode());\n        },\n        not() {\n            return (0, exports._Expr)(_expr.not());\n        },\n        nUnique() {\n            return (0, exports._Expr)(_expr.nUnique());\n        },\n        or(other) {\n            const expr = (0, exports.exprToLitOrExpr)(other).inner();\n            return (0, exports._Expr)(_expr.or(expr));\n        },\n        over(...exprs) {\n            const partitionBy = (0, utils_1.selectionToExprList)(exprs, false);\n            return wrap(\"over\", partitionBy);\n        },\n        pow(exponent) {\n            return (0, exports._Expr)(_expr.pow(exponent?.exponent ?? exponent));\n        },\n        prefix(prefix) {\n            return (0, exports._Expr)(_expr.prefix(prefix));\n        },\n        quantile(quantile, interpolation = \"nearest\") {\n            if (exports.Expr.isExpr(quantile)) {\n                quantile = quantile._expr;\n            }\n            else {\n                quantile = polars_internal_1.default.lit(quantile);\n            }\n            return (0, exports._Expr)(_expr.quantile(quantile, interpolation));\n        },\n        rank(method = \"average\", reverse = false) {\n            return (0, exports._Expr)(_expr.rank(method?.method ?? method, method?.reverse ?? reverse));\n        },\n        reinterpret(signed = true) {\n            signed = signed?.signed ?? signed;\n            return (0, exports._Expr)(_expr.reinterpret(signed));\n        },\n        repeatBy(expr) {\n            const e = (0, exports.exprToLitOrExpr)(expr, false)._expr;\n            return (0, exports._Expr)(_expr.repeatBy(e));\n        },\n        replace(old, newValue) {\n            let oldIn = old;\n            let newIn = newValue;\n            if (old && typeof old === \"object\" && !Array.isArray(old)) {\n                oldIn = Object.keys(old[\"old\"]);\n                newIn = Object.values(old[\"old\"]);\n            }\n            return (0, exports._Expr)(_expr.replace((0, exports.exprToLitOrExpr)(oldIn)._expr, (0, exports.exprToLitOrExpr)(newIn)._expr));\n        },\n        replaceStrict(old, newValue, defaultValue, returnDtype) {\n            let oldIn = old;\n            let newIn = newValue;\n            let defIn = defaultValue;\n            if (old && typeof old === \"object\" && !Array.isArray(old)) {\n                oldIn = Object.keys(old[\"old\"]);\n                newIn = Object.values(old[\"old\"]);\n                defIn = old[\"default_\"];\n            }\n            return (0, exports._Expr)(_expr.replaceStrict((0, exports.exprToLitOrExpr)(oldIn)._expr, (0, exports.exprToLitOrExpr)(newIn)._expr, defIn ? (0, exports.exprToLitOrExpr)(defIn)._expr : undefined, returnDtype));\n        },\n        reverse() {\n            return (0, exports._Expr)(_expr.reverse());\n        },\n        rollingMax: rolling(\"rollingMax\"),\n        rollingMean: rolling(\"rollingMean\"),\n        rollingMin: rolling(\"rollingMin\"),\n        rollingSum: rolling(\"rollingSum\"),\n        rollingStd: rolling(\"rollingStd\"),\n        rollingVar: rolling(\"rollingVar\"),\n        rollingMedian: rolling(\"rollingMedian\"),\n        rollingQuantile(val, interpolation, windowSize, weights, minPeriods, center, by, closedWindow, warnIfUnsorted) {\n            if (typeof val === \"number\") {\n                return wrap(\"rollingQuantile\", {\n                    windowSize: `${windowSize}i`,\n                    weights,\n                    minPeriods,\n                    center,\n                });\n            }\n            windowSize =\n                val?.[\"windowSize\"] ?? (typeof val === \"number\" ? val : null);\n            if (windowSize === null) {\n                throw new Error(\"window size is required\");\n            }\n            return wrap(\"rollingQuantile\", val.quantile, val.interpolation ?? \"nearest\", windowSize, val?.[\"weights\"] ?? weights ?? null, val?.[\"minPeriods\"] ?? minPeriods ?? windowSize, val?.[\"center\"] ?? center ?? false, val?.[\"by\"] ?? by, closedWindow, val?.[\"warnIfUnsorted\"] ?? warnIfUnsorted ?? true);\n        },\n        rollingSkew(val, bias = true) {\n            if (typeof val === \"number\") {\n                return wrap(\"rollingSkew\", val, bias);\n            }\n            return wrap(\"rollingSkew\", val.windowSize, val.bias ?? bias);\n        },\n        round(decimals) {\n            return (0, exports._Expr)(_expr.round(decimals?.decimals ?? decimals));\n        },\n        sample(opts, frac, withReplacement = false, seed) {\n            if (opts?.n !== undefined || opts?.frac !== undefined) {\n                return this.sample(opts.n, opts.frac, opts.withReplacement, seed);\n            }\n            if (typeof opts === \"number\") {\n                throw new Error(\"sample_n is not yet supported for expr\");\n            }\n            if (typeof frac === \"number\") {\n                return wrap(\"sampleFrac\", frac, withReplacement, false, seed);\n            }\n            throw new TypeError(\"must specify either 'frac' or 'n'\");\n        },\n        shift(periods) {\n            return (0, exports._Expr)(_expr.shift((0, exports.exprToLitOrExpr)(periods)._expr));\n        },\n        shiftAndFill(optOrPeriods, fillValue) {\n            if (typeof optOrPeriods === \"number\") {\n                return wrap(\"shiftAndFill\", optOrPeriods, fillValue);\n            }\n            return wrap(\"shiftAndFill\", optOrPeriods.periods, optOrPeriods.fillValue);\n        },\n        skew(bias) {\n            return wrap(\"skew\", bias?.bias ?? bias ?? true);\n        },\n        sin() {\n            return (0, exports._Expr)(_expr.sin());\n        },\n        sinh() {\n            return (0, exports._Expr)(_expr.sinh());\n        },\n        slice(arg, len) {\n            if (typeof arg === \"number\") {\n                return wrap(\"slice\", polars_internal_1.default.lit(arg), polars_internal_1.default.lit(len));\n            }\n            return wrap(\"slice\", polars_internal_1.default.lit(arg.offset), polars_internal_1.default.lit(arg.length));\n        },\n        sort(reverse = false, nullsLast = false, maintain_order = false) {\n            if (typeof reverse === \"boolean\") {\n                return wrap(\"sortWith\", reverse, nullsLast, false, maintain_order);\n            }\n            return wrap(\"sortWith\", reverse?.reverse ?? false, reverse?.nullsLast ?? nullsLast, false, reverse?.maintain_order ?? maintain_order);\n        },\n        sortBy(arg, reverse = false) {\n            if (arg?.by !== undefined) {\n                return this.sortBy(arg.by, arg.reverse);\n            }\n            reverse = Array.isArray(reverse) ? reverse.flat() : [reverse];\n            const by = (0, utils_1.selectionToExprList)(arg, false);\n            return wrap(\"sortBy\", by, reverse);\n        },\n        std() {\n            return (0, exports._Expr)(_expr.std());\n        },\n        suffix(suffix) {\n            return (0, exports._Expr)(_expr.suffix(suffix));\n        },\n        sum() {\n            return (0, exports._Expr)(_expr.sum());\n        },\n        tail(length) {\n            return (0, exports._Expr)(_expr.tail(length));\n        },\n        tan() {\n            return (0, exports._Expr)(_expr.tan());\n        },\n        tanh() {\n            return (0, exports._Expr)(_expr.tanh());\n        },\n        unique(opt) {\n            if (opt || opt?.maintainOrder) {\n                return wrap(\"uniqueStable\");\n            }\n            return wrap(\"unique\");\n        },\n        upperBound() {\n            return (0, exports._Expr)(_expr.upperBound());\n        },\n        where(expr) {\n            return this.filter(expr);\n        },\n        var() {\n            return (0, exports._Expr)(_expr.var());\n        },\n        add: wrapExprArg(\"add\"),\n        sub: wrapExprArg(\"sub\"),\n        div: wrapExprArg(\"div\"),\n        mul: wrapExprArg(\"mul\"),\n        rem: wrapExprArg(\"rem\"),\n        plus: wrapExprArg(\"add\"),\n        minus: wrapExprArg(\"sub\"),\n        divideBy: wrapExprArg(\"div\"),\n        multiplyBy: wrapExprArg(\"mul\"),\n        modulo: wrapExprArg(\"rem\"),\n        eq: wrapExprArg(\"eq\"),\n        equals: wrapExprArg(\"eq\"),\n        gtEq: wrapExprArg(\"gtEq\"),\n        greaterThanEquals: wrapExprArg(\"gtEq\"),\n        gt: wrapExprArg(\"gt\"),\n        greaterThan: wrapExprArg(\"gt\"),\n        ltEq: wrapExprArg(\"ltEq\"),\n        lessThanEquals: wrapExprArg(\"ltEq\"),\n        lt: wrapExprArg(\"lt\"),\n        lessThan: wrapExprArg(\"lt\"),\n        neq: wrapExprArg(\"neq\"),\n        notEquals: wrapExprArg(\"neq\"),\n    };\n}",
    "DataFrame": "function DataFrameConstructor(data, options) {\n    if (!data) {\n        return (0, exports._DataFrame)(objToDF({}));\n    }\n    if (Array.isArray(data)) {\n        return (0, exports._DataFrame)((0, construction_1.arrayToJsDataFrame)(data, options));\n    }\n    return (0, exports._DataFrame)(objToDF(data, options));\n}",
    "LazyDataFrame": "(_ldf) => {\n    const unwrap = (method, ...args) => {\n        return _ldf[method](...args);\n    };\n    const wrap = (method, ...args) => {\n        return (0, exports._LazyDataFrame)(unwrap(method, ...args));\n    };\n    return {\n        _ldf,\n        [inspect]() {\n            return _ldf.describeOptimizedPlan();\n        },\n        get [Symbol.toStringTag]() {\n            return \"LazyDataFrame\";\n        },\n        get columns() {\n            return _ldf.columns;\n        },\n        describePlan() {\n            return _ldf.describePlan();\n        },\n        describeOptimizedPlan() {\n            return _ldf.describeOptimizedPlan();\n        },\n        cache() {\n            return (0, exports._LazyDataFrame)(_ldf.cache());\n        },\n        clone() {\n            return (0, exports._LazyDataFrame)(_ldf.clone());\n        },\n        collectSync() {\n            return (0, dataframe_1._DataFrame)(_ldf.collectSync());\n        },\n        collect(opts) {\n            if (opts?.noOptimization) {\n                opts.predicatePushdown = false;\n                opts.projectionPushdown = false;\n                opts.slicePushdown = false;\n                opts.commSubplanElim = false;\n                opts.commSubexprElim = false;\n            }\n            if (opts?.streaming)\n                opts.commSubplanElim = false;\n            if (opts) {\n                _ldf = _ldf.optimizationToggle(opts.typeCoercion, opts.predicatePushdown, opts.projectionPushdown, opts.simplifyExpression, opts.slicePushdown, opts.commSubplanElim, opts.commSubexprElim, opts.streaming);\n            }\n            return _ldf.collect().then(dataframe_1._DataFrame);\n        },\n        drop(...cols) {\n            return (0, exports._LazyDataFrame)(_ldf.dropColumns(cols.flat(2)));\n        },\n        distinct(...args) {\n            return (0, exports._LazyDataFrame)(_ldf.unique(...args));\n        },\n        unique(opts = false, subset, keep = \"first\") {\n            const defaultOptions = {\n                maintainOrder: false,\n                keep: \"first\",\n            };\n            if (typeof opts === \"boolean\") {\n                const o = { ...defaultOptions, maintainOrder: opts, subset, keep };\n                return (0, exports._LazyDataFrame)(_ldf.unique(o.maintainOrder, o?.subset?.flat(2), o.keep));\n            }\n            if (opts.subset) {\n                opts.subset = [opts.subset].flat(3);\n            }\n            const o = { ...defaultOptions, ...opts };\n            return (0, exports._LazyDataFrame)(_ldf.unique(o.maintainOrder, o.subset, o.keep));\n        },\n        dropNulls(...subset) {\n            if (subset.length) {\n                return wrap(\"dropNulls\", subset.flat(2));\n            }\n            return wrap(\"dropNulls\");\n        },\n        explode(...columns) {\n            if (!columns.length) {\n                const cols = (0, utils_1.selectionToExprList)(_ldf.columns, false);\n                return wrap(\"explode\", cols);\n            }\n            const column = (0, utils_1.selectionToExprList)(columns, false);\n            return wrap(\"explode\", column);\n        },\n        fetchSync(numRows, opts) {\n            if (opts?.noOptimization) {\n                opts.predicatePushdown = false;\n                opts.projectionPushdown = false;\n                opts.slicePushdown = false;\n                opts.commSubplanElim = false;\n                opts.commSubexprElim = false;\n            }\n            if (opts?.streaming)\n                opts.commSubplanElim = false;\n            if (opts) {\n                _ldf = _ldf.optimizationToggle(opts.typeCoercion, opts.predicatePushdown, opts.projectionPushdown, opts.simplifyExpr, opts.slicePushdown, opts.commSubplanElim, opts.commSubexprElim, opts.streaming);\n            }\n            return (0, dataframe_1._DataFrame)(_ldf.fetchSync(numRows));\n        },\n        fetch(numRows, opts) {\n            if (opts?.noOptimization) {\n                opts.predicatePushdown = false;\n                opts.projectionPushdown = false;\n                opts.slicePushdown = false;\n                opts.commSubplanElim = false;\n                opts.commSubexprElim = false;\n            }\n            if (opts?.streaming)\n                opts.commSubplanElim = false;\n            if (opts) {\n                _ldf = _ldf.optimizationToggle(opts.typeCoercion, opts.predicatePushdown, opts.projectionPushdown, opts.simplifyExpr, opts.slicePushdown, opts.commSubplanElim, opts.commSubexprElim, opts.streaming);\n            }\n            return _ldf.fetch(numRows).then(dataframe_1._DataFrame);\n        },\n        first() {\n            return this.fetchSync(1);\n        },\n        fillNull(exprOrValue) {\n            const fillValue = (0, expr_1.exprToLitOrExpr)(exprOrValue)._expr;\n            return (0, exports._LazyDataFrame)(_ldf.fillNull(fillValue));\n        },\n        filter(exprOrValue) {\n            const predicate = (0, expr_1.exprToLitOrExpr)(exprOrValue, false)._expr;\n            return (0, exports._LazyDataFrame)(_ldf.filter(predicate));\n        },\n        groupBy(opt, maintainOrder = true) {\n            if (opt?.by !== undefined) {\n                const by = (0, utils_1.selectionToExprList)([opt.by], false);\n                return (0, groupby_1._LazyGroupBy)(_ldf.groupby(by, opt.maintainOrder));\n            }\n            const by = (0, utils_1.selectionToExprList)([opt], false);\n            return (0, groupby_1._LazyGroupBy)(_ldf.groupby(by, maintainOrder));\n        },\n        groupByRolling({ indexColumn, by, period, offset, closed, check_sorted }) {\n            offset = offset ?? `-${period}`;\n            closed = closed ?? \"right\";\n            by = prepareGroupbyInputs(by);\n            check_sorted = check_sorted ?? false;\n            const lgb = _ldf.groupbyRolling(polars_internal_1.default.col(indexColumn), period, offset, closed, by, check_sorted);\n            return (0, groupby_1._LazyGroupBy)(lgb);\n        },\n        groupByDynamic({ indexColumn, every, period, offset, includeBoundaries, closed, by, start_by, check_sorted, }) {\n            period = period ?? every;\n            offset = offset ?? `-${period}`;\n            closed = closed ?? \"right\";\n            by = prepareGroupbyInputs(by);\n            includeBoundaries = includeBoundaries ?? false;\n            start_by = start_by ?? \"monday\";\n            check_sorted = check_sorted ?? false;\n            const lgb = _ldf.groupbyDynamic(polars_internal_1.default.col(indexColumn), every, period, offset, includeBoundaries, closed, by, start_by, check_sorted);\n            return (0, groupby_1._LazyGroupBy)(lgb);\n        },\n        head(len = 5) {\n            return (0, exports._LazyDataFrame)(_ldf.slice(0, len));\n        },\n        inner() {\n            return _ldf;\n        },\n        join(df, options) {\n            options = {\n                how: \"inner\",\n                suffix: \"right\",\n                allowParallel: true,\n                forceParallel: false,\n                ...options,\n            };\n            const { how, suffix, allowParallel, forceParallel } = options;\n            if (how === \"cross\") {\n                return (0, exports._LazyDataFrame)(_ldf.join(df._ldf, [], [], allowParallel, forceParallel, how, suffix, [], []));\n            }\n            let leftOn;\n            let rightOn;\n            if (options.on) {\n                const on = (0, utils_1.selectionToExprList)(options.on, false);\n                leftOn = on;\n                rightOn = on;\n            }\n            else if ((options.leftOn && !options.rightOn) ||\n                (options.rightOn && !options.leftOn)) {\n                throw new TypeError(\"You should pass the column to join on as an argument.\");\n            }\n            else {\n                leftOn = (0, utils_1.selectionToExprList)(options.leftOn, false);\n                rightOn = (0, utils_1.selectionToExprList)(options.rightOn, false);\n            }\n            const ldf = _ldf.join(df._ldf, leftOn, rightOn, allowParallel, forceParallel, how, suffix, [], []);\n            return (0, exports._LazyDataFrame)(ldf);\n        },\n        joinAsof(other, options) {\n            options = {\n                suffix: \"_right\",\n                allowParallel: true,\n                forceParallel: false,\n                strategy: \"backward\",\n                ...options,\n            };\n            const { suffix, strategy, allowParallel, forceParallel } = options;\n            let leftOn;\n            let rightOn;\n            if (!other?._ldf) {\n                throw new TypeError(\"Expected a 'lazyFrame' as join table\");\n            }\n            if (options.on) {\n                leftOn = rightOn = options.on;\n            }\n            else if ((options.leftOn && !options.rightOn) ||\n                (options.rightOn && !options.leftOn)) {\n                throw new TypeError(\"You should pass the column to join on as an argument.\");\n            }\n            else {\n                leftOn = options.leftOn;\n                rightOn = options.rightOn;\n            }\n            let byLeft;\n            if (typeof options.byLeft === \"string\") {\n                byLeft = [options.byLeft];\n            }\n            else if (Array.isArray(options.byLeft)) {\n                byLeft = options.byLeft;\n            }\n            let byRight;\n            if (typeof options.byRight === \"string\") {\n                byRight = [options.byRight];\n            }\n            else if (Array.isArray(options.byRight)) {\n                byRight = options.byRight;\n            }\n            if (typeof options.by === \"string\") {\n                byLeft = byRight = [options.by];\n            }\n            else if (Array.isArray(options.by)) {\n                byLeft = byRight = options.by;\n            }\n            let toleranceStr;\n            let toleranceNum;\n            if (typeof options.tolerance === \"string\") {\n                toleranceStr = options.tolerance;\n            }\n            else {\n                toleranceNum = options.tolerance;\n            }\n            const ldf = _ldf.joinAsof(other._ldf, polars_internal_1.default.col(leftOn), polars_internal_1.default.col(rightOn), byLeft, byRight, allowParallel, forceParallel, suffix, strategy, toleranceNum, toleranceStr);\n            return (0, exports._LazyDataFrame)(ldf);\n        },\n        last() {\n            return (0, exports._LazyDataFrame)(_ldf.tail(1));\n        },\n        limit(len = 5) {\n            return (0, exports._LazyDataFrame)(_ldf.slice(0, len));\n        },\n        max() {\n            return (0, exports._LazyDataFrame)(_ldf.max());\n        },\n        mean() {\n            return (0, exports._LazyDataFrame)(_ldf.mean());\n        },\n        median() {\n            return (0, exports._LazyDataFrame)(_ldf.median());\n        },\n        melt(ids, values) {\n            return (0, exports._LazyDataFrame)(_ldf.unpivot((0, utils_1.columnOrColumnsStrict)(ids), (0, utils_1.columnOrColumnsStrict)(values)));\n        },\n        unpivot(ids, values) {\n            return (0, exports._LazyDataFrame)(_ldf.unpivot((0, utils_1.columnOrColumnsStrict)(ids), (0, utils_1.columnOrColumnsStrict)(values)));\n        },\n        min() {\n            return (0, exports._LazyDataFrame)(_ldf.min());\n        },\n        quantile(quantile, interpolation = \"nearest\") {\n            return (0, exports._LazyDataFrame)(_ldf.quantile(quantile, interpolation));\n        },\n        rename(mapping) {\n            const existing = Object.keys(mapping);\n            const replacements = Object.values(mapping);\n            return (0, exports._LazyDataFrame)(_ldf.rename(existing, replacements));\n        },\n        reverse() {\n            return (0, exports._LazyDataFrame)(_ldf.reverse());\n        },\n        select(...exprs) {\n            const selections = (0, utils_1.selectionToExprList)(exprs, false);\n            return (0, exports._LazyDataFrame)(_ldf.select(selections));\n        },\n        shift(periods) {\n            return (0, exports._LazyDataFrame)(_ldf.shift(periods));\n        },\n        shiftAndFill(opts, fillValue) {\n            if (typeof opts === \"number\") {\n                return (0, exports._LazyDataFrame)(_ldf.shiftAndFill(opts, fillValue));\n            }\n            return (0, exports._LazyDataFrame)(_ldf.shiftAndFill(opts?.n, opts?.fillValue));\n        },\n        slice(opt, len) {\n            if (opt?.offset !== undefined) {\n                return (0, exports._LazyDataFrame)(_ldf.slice(opt.offset, opt.length));\n            }\n            return (0, exports._LazyDataFrame)(_ldf.slice(opt, len));\n        },\n        sort(arg, descending = false, nulls_last = false, maintain_order = false) {\n            if (arg?.by !== undefined) {\n                return this.sort(arg.by, arg.descending, arg.nulls_last, arg.maintain_order);\n            }\n            if (typeof arg === \"string\") {\n                return wrap(\"sort\", arg, descending, nulls_last, maintain_order);\n            }\n            const by = (0, utils_1.selectionToExprList)(arg, false);\n            return wrap(\"sortByExprs\", by, descending, nulls_last, maintain_order);\n        },\n        std() {\n            return (0, exports._LazyDataFrame)(_ldf.std());\n        },\n        sum() {\n            return (0, exports._LazyDataFrame)(_ldf.sum());\n        },\n        var() {\n            return (0, exports._LazyDataFrame)(_ldf.var());\n        },\n        tail(length = 5) {\n            return (0, exports._LazyDataFrame)(_ldf.tail(length));\n        },\n        toJSON(...args) {\n            // this is passed by `JSON.stringify` when calling `toJSON()`\n            if (args[0] === \"\") {\n                return JSON.parse(_ldf.serialize(\"json\").toString());\n            }\n            return _ldf.serialize(\"json\").toString();\n        },\n        serialize(format) {\n            return _ldf.serialize(format);\n        },\n        withColumn(expr) {\n            return (0, exports._LazyDataFrame)(_ldf.withColumn(expr._expr));\n        },\n        withColumns(...columns) {\n            const exprs = (0, utils_1.selectionToExprList)(columns, false);\n            return (0, exports._LazyDataFrame)(_ldf.withColumns(exprs));\n        },\n        withColumnRenamed(existing, replacement) {\n            return (0, exports._LazyDataFrame)(_ldf.rename([existing], [replacement]));\n        },\n        withRowCount(name = \"row_nr\") {\n            return (0, exports._LazyDataFrame)(_ldf.withRowCount(name));\n        },\n        sinkCSV(path, options = {}) {\n            options.maintainOrder = options.maintainOrder ?? false;\n            _ldf.sinkCsv(path, options);\n        },\n        sinkParquet(path, options = {}) {\n            options.compression = options.compression ?? \"zstd\";\n            options.statistics = options.statistics ?? false;\n            _ldf.sinkParquet(path, options);\n        },\n    };\n}",
    "Series": "(arg0, arg1, dtype, strict) => {\n    if (typeof arg0 === \"string\") {\n        const _s = (0, construction_1.arrayToJsSeries)(arg0, arg1, dtype, strict);\n        return _Series(_s);\n    }\n    return SeriesConstructor(\"\", arg0);\n}",
    "Config": {
      "setUtf8Tables": "setUtf8Tables() {\n        process.env[\"POLARS_FMT_NO_UTF8\"] = undefined;\n        return this;\n    }",
      "setAsciiTables": "setAsciiTables() {\n        process.env[\"POLARS_FMT_NO_UTF8\"] = \"1\";\n        return this;\n    }",
      "setTblWidthChars": "setTblWidthChars(width) {\n        process.env[\"POLARS_TABLE_WIDTH\"] = String(width);\n        return this;\n    }",
      "setTblRows": "setTblRows(n) {\n        process.env[\"POLARS_FMT_MAX_ROWS\"] = String(n);\n        return this;\n    }",
      "setTblCols": "setTblCols(n) {\n        process.env[\"POLARS_FMT_MAX_COLS\"] = String(n);\n        return this;\n    }",
      "setGlobalStringCache": "setGlobalStringCache() {\n        native_polars_1.default.toggleStringCache(true);\n        return this;\n    }",
      "unsetGlobalStringCache": "unsetGlobalStringCache() {\n        native_polars_1.default.toggleStringCache(false);\n        return this;\n    }"
    },
    "Field": "class Field {\n    name;\n    dtype;\n    constructor(name, dtype) {\n        this.name = name;\n        this.dtype = dtype;\n    }\n    toString() {\n        return `Field(\"${this.name}\", ${this.dtype})`;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            dtype: this.dtype,\n        };\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.toJSON();\n    }\n}",
    "repeat": "function repeat(value, n, name = \"\") {\n    const dtype = (0, construction_1.jsTypeToPolarsType)(value);\n    const s = polars_internal_1.default.JsSeries.repeat(name, value, n, dtype);\n    return (0, series_1._Series)(s);\n}",
    "concat": "function concat(items, options = { rechunk: true, how: \"vertical\" }) {\n    const { rechunk, how } = options;\n    if (!items.length) {\n        throw new RangeError(\"cannot concat empty list\");\n    }\n    if ((0, utils_1.isDataFrameArray)(items)) {\n        let df;\n        switch (how) {\n            case \"vertical\":\n                df = items.reduce((acc, curr) => acc.vstack(curr));\n                break;\n            case \"horizontal\":\n                df = (0, dataframe_1._DataFrame)(polars_internal_1.default.horizontalConcat(items.map((i) => i.inner())));\n                break;\n            case \"diagonal\":\n                df = (0, dataframe_1._DataFrame)(polars_internal_1.default.diagonalConcat(items.map((i) => i.inner())));\n                break;\n            default:\n                throw new TypeError(\"unknown concat how option\");\n        }\n        return rechunk ? df.rechunk() : df;\n    }\n    if ((0, utils_1.isLazyDataFrameArray)(items)) {\n        const df = (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.concatLf(items.map((i) => i.inner()), how, rechunk));\n        return df;\n    }\n    if ((0, utils_1.isSeriesArray)(items)) {\n        const s = items.reduce((acc, curr) => acc.concat(curr));\n        return rechunk ? s.rechunk() : s;\n    }\n    throw new TypeError(\"can only concat series and dataframes\");\n}",
    "scanCSV": "function scanCSV(path, options) {\n    options = { ...scanCsvDefaultOptions, ...options };\n    return (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.scanCsv(path, options));\n}",
    "scanJson": "function scanJson(path, options) {\n    options = { ...readJsonDefaultOptions, ...options };\n    return (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.scanJson(path, options));\n}",
    "scanIPC": "function scanIPC(path, options = {}) {\n    return (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.scanIpc(path, options));\n}",
    "scanParquet": "function scanParquet(source, options = {}) {\n    const defaultOptions = { parallel: \"auto\" };\n    const pliOptions = { ...defaultOptions, ...options };\n    return (0, dataframe_2._LazyDataFrame)(polars_internal_1.default.scanParquet(source, pliOptions));\n}",
    "readRecords": "function readRecords(records, options) {\n    if (options?.schema) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.fromRows(records, options.schema));\n    }\n    return (0, dataframe_1._DataFrame)(polars_internal_1.default.fromRows(records, undefined, options?.inferSchemaLength));\n}",
    "readCSV": "function readCSV(pathOrBody, options) {\n    options = { ...readCsvDefaultOptions, ...options };\n    const extensions = [\".tsv\", \".csv\"];\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readCsv(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, extensions);\n        if (inline) {\n            const buf = Buffer.from(pathOrBody, \"utf-8\");\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readCsv(buf, options));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readCsv(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
    "readIPC": "function readIPC(pathOrBody, options = {}) {\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpc(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, [\".ipc\"]);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpc(Buffer.from(pathOrBody, \"utf-8\"), options));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpc(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
    "readIPCStream": "function readIPCStream(pathOrBody, options = {}) {\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpcStream(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, [\".ipc\"]);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpcStream(Buffer.from(pathOrBody, \"utf-8\"), options));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readIpcStream(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
    "readJSON": "function readJSON(pathOrBody, options = readJsonDefaultOptions) {\n    options = { ...readJsonDefaultOptions, ...options };\n    const method = options.format === \"lines\" ? polars_internal_1.default.readJsonLines : polars_internal_1.default.readJson;\n    const extensions = [\".ndjson\", \".json\", \".jsonl\"];\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readJson(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, extensions);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(method(Buffer.from(pathOrBody, \"utf-8\"), options));\n        }\n        return (0, dataframe_1._DataFrame)(method(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
    "readParquet": "function readParquet(pathOrBody, options) {\n    const pliOptions = {};\n    if (typeof options?.columns?.[0] === \"number\") {\n        pliOptions.projection = options?.columns;\n    }\n    else {\n        pliOptions.columns = options?.columns;\n    }\n    pliOptions.nRows = options?.numRows;\n    pliOptions.rowCount = options?.rowCount;\n    const parallel = options?.parallel ?? \"auto\";\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readParquet(pathOrBody, pliOptions, parallel));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, [\".parquet\"]);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readParquet(Buffer.from(pathOrBody), pliOptions, parallel));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readParquet(pathOrBody, pliOptions, parallel));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
    "readAvro": "function readAvro(pathOrBody, options = {}) {\n    if (Buffer.isBuffer(pathOrBody)) {\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readAvro(pathOrBody, options));\n    }\n    if (typeof pathOrBody === \"string\") {\n        const inline = !(0, utils_1.isPath)(pathOrBody, [\".avro\"]);\n        if (inline) {\n            return (0, dataframe_1._DataFrame)(polars_internal_1.default.readAvro(Buffer.from(pathOrBody), options));\n        }\n        return (0, dataframe_1._DataFrame)(polars_internal_1.default.readAvro(pathOrBody, options));\n    }\n    throw new Error(\"must supply either a path or body\");\n}",
    "readCSVStream": "function readCSVStream(stream, options) {\n    const batchSize = options?.batchSize ?? 10000;\n    let count = 0;\n    const end = options?.endRows ?? Number.POSITIVE_INFINITY;\n    return new Promise((resolve, reject) => {\n        const s = stream.pipe(new LineBatcher({ batchSize }));\n        const chunks = [];\n        s.on(\"data\", (chunk) => {\n            // early abort if 'end rows' is specified\n            if (count <= end) {\n                chunks.push(chunk);\n            }\n            else {\n                s.end();\n            }\n            count += batchSize;\n        }).on(\"end\", () => {\n            try {\n                const buff = Buffer.concat(chunks);\n                const df = readCSVBuffer(buff, options);\n                resolve(df);\n            }\n            catch (err) {\n                reject(err);\n            }\n        });\n    });\n}",
    "readJSONStream": "function readJSONStream(stream, options = readJsonDefaultOptions) {\n    options = { ...readJsonDefaultOptions, ...options };\n    return new Promise((resolve, reject) => {\n        const chunks = [];\n        stream\n            .pipe(new LineBatcher({ batchSize: options.batchSize }))\n            .on(\"data\", (chunk) => {\n            try {\n                const df = (0, dataframe_1._DataFrame)(polars_internal_1.default.readJson(chunk, options));\n                chunks.push(df);\n            }\n            catch (err) {\n                reject(err);\n            }\n        })\n            .on(\"end\", () => {\n            try {\n                const df = (0, functions_1.concat)(chunks);\n                resolve(df);\n            }\n            catch (err) {\n                reject(err);\n            }\n        });\n    });\n}",
    "col": "function col(col) {\n    if (series_1.Series.isSeries(col)) {\n        col = col.toArray();\n    }\n    if (Array.isArray(col)) {\n        return (0, expr_1._Expr)(polars_internal_1.default.cols(col));\n    }\n    if (typeof col === \"object\" && Object.values(col)[0] === \"DataType\") {\n        return (0, expr_1._Expr)(polars_internal_1.default.dtypeCols([col]));\n    }\n    return (0, expr_1._Expr)(polars_internal_1.default.col(col));\n}",
    "nth": "function nth(n) {\n    return (0, expr_1._Expr)(polars_internal_1.default.nth(n));\n}",
    "cols": "function cols(...cols) {\n    return col(cols.flat());\n}",
    "lit": "function lit(value) {\n    if (Array.isArray(value)) {\n        value = (0, series_1.Series)(value);\n    }\n    if (series_1.Series.isSeries(value)) {\n        return (0, expr_1._Expr)(polars_internal_1.default.lit(value.inner()));\n    }\n    return (0, expr_1._Expr)(polars_internal_1.default.lit(value));\n}",
    "intRange": "function intRange(opts, end, step = 1, dtype = datatypes_1.DataType.Int64, eager) {\n    // @deprecated since 0.15.0\n    if (typeof opts?.low === \"number\") {\n        return intRange(opts.low, opts.high, opts.step, opts.dtype, opts.eager);\n    }\n    if (typeof opts?.start === \"number\") {\n        return intRange(opts.start, opts.end, opts.step, opts.dtype, opts.eager);\n    }\n    // if expression like pl.len() passed\n    if (end === undefined || end === null) {\n        end = opts;\n        opts = 0;\n    }\n    const start = (0, expr_1.exprToLitOrExpr)(opts, false);\n    end = (0, expr_1.exprToLitOrExpr)(end, false);\n    if (eager) {\n        const df = (0, dataframe_1.DataFrame)({ a: [1] });\n        return df\n            .select(intRange(start, end, step).alias(\"intRange\"))\n            .getColumn(\"intRange\");\n    }\n    return (0, expr_1._Expr)(polars_internal_1.default.intRange(start, end, step, dtype));\n}",
    "intRanges": "function intRanges(start, end, step = 1, dtype = datatypes_1.DataType.Int64, eager) {\n    start = (0, expr_1.exprToLitOrExpr)(start, false);\n    end = (0, expr_1.exprToLitOrExpr)(end, false);\n    step = (0, expr_1.exprToLitOrExpr)(step, false);\n    if (eager) {\n        const df = (0, dataframe_1.DataFrame)({ a: [1] });\n        return df\n            .select(intRanges(start, end, step, dtype).alias(\"intRanges\"))\n            .getColumn(\"intRanges\");\n    }\n    return (0, expr_1._Expr)(polars_internal_1.default.intRanges(start, end, step, dtype));\n}",
    "argSortBy": "function argSortBy(exprs, descending = false) {\n    if (!Array.isArray(descending)) {\n        descending = Array.from({ length: exprs.length }, () => descending);\n    }\n    const by = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.argSortBy(by, descending));\n}",
    "avg": "function avg(column) {\n    return mean(column);\n}",
    "concatList": "function concatList(...exprs) {\n    const items = (0, utils_1.selectionToExprList)(exprs, false);\n    return expr_1.Expr(polars_internal_1.default.concatLst(items));\n}",
    "concatString": "function concatString(opts, sep = \",\", ignoreNulls = true) {\n    if (opts?.exprs) {\n        return concatString(opts.exprs, opts.sep, opts.ignoreNulls);\n    }\n    const items = (0, utils_1.selectionToExprList)(opts, false);\n    return expr_1.Expr(polars_internal_1.default.concatStr(items, sep, ignoreNulls));\n}",
    "count": "function count(column) {\n    if (series_1.Series.isSeries(column)) {\n        return column.len();\n    }\n    return col(column).count();\n}",
    "cov": "function cov(a, b, ddof = 1) {\n    a = (0, expr_1.exprToLitOrExpr)(a, false);\n    b = (0, expr_1.exprToLitOrExpr)(b, false);\n    return (0, expr_1._Expr)(polars_internal_1.default.cov(a, b, ddof));\n}",
    "exclude": "function exclude(...columns) {\n    return col(\"*\").exclude(columns);\n}",
    "element": "function element() {\n    return col(\"\");\n}",
    "first": "function first(column) {\n    if (!column) {\n        return (0, expr_1._Expr)(polars_internal_1.default.first());\n    }\n    if (series_1.Series.isSeries(column)) {\n        if (column.length) {\n            return column.get(0);\n        }\n        throw new RangeError(\"The series is empty, so no first value can be returned.\");\n    }\n    return col(column).first();\n}",
    "format": "function format(strings, ...expr) {\n    if (typeof strings === \"string\") {\n        const s = strings.split(\"{}\");\n        if (s.length - 1 !== expr.length) {\n            throw new RangeError(\"number of placeholders should equal the number of arguments\");\n        }\n        return format(s, ...expr);\n    }\n    const d = (0, utils_1.range)(0, Math.max(strings.length, expr.length))\n        .flatMap((i) => {\n        const sVal = strings[i] ? lit(strings[i]) : [];\n        const exprVal = expr[i] ? (0, expr_1.exprToLitOrExpr)(expr[i], false) : [];\n        return [sVal, exprVal];\n    })\n        .flat();\n    return concatString(d, \"\");\n}",
    "groups": "function groups(column) {\n    return col(column).aggGroups();\n}",
    "head": "function head(column, n) {\n    if (series_1.Series.isSeries(column)) {\n        return column.head(n);\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).head(n);\n}",
    "last": "function last(column) {\n    if (series_1.Series.isSeries(column)) {\n        if (column.length) {\n            return column.get(-1);\n        }\n        throw new RangeError(\"The series is empty, so no last value can be returned.\");\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).last();\n}",
    "len": "function len() {\n    return (0, expr_1._Expr)(polars_internal_1.default.len());\n}",
    "mean": "function mean(column) {\n    if (series_1.Series.isSeries(column)) {\n        return column.mean();\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).mean();\n}",
    "median": "function median(column) {\n    if (series_1.Series.isSeries(column)) {\n        return column.median();\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).median();\n}",
    "nUnique": "function nUnique(column) {\n    if (series_1.Series.isSeries(column)) {\n        return column.nUnique();\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).nUnique();\n}",
    "pearsonCorr": "function pearsonCorr(a, b) {\n    a = (0, expr_1.exprToLitOrExpr)(a, false);\n    b = (0, expr_1.exprToLitOrExpr)(b, false);\n    return (0, expr_1._Expr)(polars_internal_1.default.pearsonCorr(a, b));\n}",
    "quantile": "function quantile(column, q) {\n    if (series_1.Series.isSeries(column)) {\n        return column.quantile(q);\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).quantile(q);\n}",
    "select": "function select(expr, ...exprs) {\n    return (0, dataframe_1.DataFrame)({}).select(expr, ...exprs);\n}",
    "struct": "function struct(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    if (series_1.Series.isSeries(exprs[0])) {\n        return select((0, expr_1._Expr)(polars_internal_1.default.asStruct(exprs.map((e) => polars_internal_1.default.lit(e.inner()))))).toSeries();\n    }\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.asStruct(exprs));\n}",
    "allHorizontal": "function allHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.allHorizontal(exprs));\n}",
    "anyHorizontal": "function anyHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.anyHorizontal(exprs));\n}",
    "minHorizontal": "function minHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.minHorizontal(exprs));\n}",
    "maxHorizontal": "function maxHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.maxHorizontal(exprs));\n}",
    "sumHorizontal": "function sumHorizontal(exprs) {\n    exprs = Array.isArray(exprs) ? exprs : [exprs];\n    exprs = (0, utils_1.selectionToExprList)(exprs);\n    return (0, expr_1._Expr)(polars_internal_1.default.sumHorizontal(exprs));\n}",
    "spearmanRankCorr": "function spearmanRankCorr(a, b) {\n    a = (0, expr_1.exprToLitOrExpr)(a, false);\n    b = (0, expr_1.exprToLitOrExpr)(b, false);\n    return (0, expr_1._Expr)(polars_internal_1.default.spearmanRankCorr(a, b, null, false));\n}",
    "tail": "function tail(column, n) {\n    if (series_1.Series.isSeries(column)) {\n        return column.tail(n);\n    }\n    return (0, expr_1.exprToLitOrExpr)(column, false).tail(n);\n}",
    "list": "function list(column) {\n    return (0, expr_1.exprToLitOrExpr)(column, false).list();\n}",
    "when": "function when(expr) {\n    return When(polars_internal_1.default.when(expr._expr));\n}",
    "version": "0.16.0",
    "Categorical": {
      "identity": "DataType"
    },
    "Int8": {
      "identity": "DataType"
    },
    "Int16": {
      "identity": "DataType"
    },
    "Int32": {
      "identity": "DataType"
    },
    "Int64": {
      "identity": "DataType"
    },
    "UInt8": {
      "identity": "DataType"
    },
    "UInt16": {
      "identity": "DataType"
    },
    "UInt32": {
      "identity": "DataType"
    },
    "UInt64": {
      "identity": "DataType"
    },
    "Float32": {
      "identity": "DataType"
    },
    "Float64": {
      "identity": "DataType"
    },
    "Bool": {
      "identity": "DataType"
    },
    "Utf8": {
      "identity": "DataType"
    },
    "String": {
      "identity": "DataType"
    },
    "List": "List(inner) {\n        return new List(inner);\n    }",
    "FixedSizeList": "FixedSizeList(inner, listSize) {\n        return new FixedSizeList(inner, listSize);\n    }",
    "Date": {
      "identity": "DataType"
    },
    "Datetime": "Datetime(timeUnit, timeZone = null) {\n        return new Datetime(timeUnit ?? \"ms\", timeZone);\n    }",
    "Time": {
      "identity": "DataType"
    },
    "Object": {
      "identity": "DataType"
    },
    "Null": {
      "identity": "DataType"
    },
    "Struct": "Struct(fields) {\n        return new Struct(fields);\n    }",
    "Decimal": "Decimal(precision, scale) {\n        return new Decimal(precision, scale);\n    }",
    "SQLContext": "function SQLContext(frames) {\n        return new sql.SQLContext(frames);\n    }"
  }
}